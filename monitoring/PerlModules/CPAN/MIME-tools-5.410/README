NAME
    MIME-tools - modules for parsing (and creating!) MIME entities

SYNOPSIS
    Here's some pretty basic code for parsing a MIME message, and outputting
    its decoded components to a given directory:

        use MIME::Parser;

        ### Create parser, and set some parsing options:
        my $parser = new MIME::Parser;
        $parser->output_under("$ENV{HOME}/mimemail");

        ### Parse input:
        $entity = $parser->parse(\*STDIN) or die "parse failed\n";

        ### Take a look at the top-level entity (and any parts it has):
        $entity->dump_skeleton;

    Here's some code which composes and sends a MIME message containing
    three parts: a text file, an attached GIF, and some more text:

        use MIME::Entity;

        ### Create the top-level, and set up the mail headers:
        $top = MIME::Entity->build(Type    =>"multipart/mixed",
                                   From    => "me\@myhost.com",
                                   To      => "you\@yourhost.com",
                                   Subject => "Hello, nurse!");

        ### Part #1: a simple text document:
        $top->attach(Path=>"./testin/short.txt");

        ### Part #2: a GIF file:
        $top->attach(Path        => "./docs/mime-sm.gif",
                     Type        => "image/gif",
                     Encoding    => "base64");

        ### Part #3: some literal text:
        $top->attach(Data=>$message);

        ### Send it:
        open MAIL, "| /usr/lib/sendmail -t -oi -oem" or die "open: $!";
        $top->print(\*MAIL);
        close MAIL;

    For more examples, look at the scripts in the examples directory of the
    MIME-tools distribution.

DESCRIPTION
    MIME-tools is a collection of Perl5 MIME:: modules for parsing,
    decoding, *and generating* single- or multipart (even nested multipart)
    MIME messages. (Yes, kids, that means you can send messages with
    attached GIF files).

REQUIREMENTS
    You will need the following installed on your system:

            File::Path
            File::Spec
            IPC::Open2              (optional)
            IO::Scalar, ...         from the IO-stringy distribution
            MIME::Base64
            MIME::QuotedPrint
            Net::SMTP
            Mail::Internet, ...     from the MailTools distribution.

    See the Makefile.PL in your distribution for the most-comprehensive list
    of prerequisite modules and their version numbers.

A QUICK TOUR
  Overview of the classes

    Here are the classes you'll generally be dealing with directly:

        (START HERE)            results() .-----------------.
              \                 .-------->| MIME::          |
               .-----------.   /          | Parser::Results |
               | MIME::    |--'           `-----------------'
               | Parser    |--.           .-----------------.
               `-----------'   \ filer()  | MIME::          |
                  | parse()     `-------->| Parser::Filer   |
                  | gives you             `-----------------'
                  | a...                                  | output_path() 
                  |                                       | determines
                  |                                       | path() of...
                  |    head()       .--------.            |
                  |    returns...   | MIME:: | get()      |
                  V       .-------->| Head   | etc...     |
               .--------./          `--------'            |
         .---> | MIME:: |                                 |
         `-----| Entity |           .--------.            |
       parts() `--------'\          | MIME:: |           /
       returns            `-------->| Body   |<---------'
       sub-entities    bodyhandle() `--------'
       (if any)        returns...       | open()
                                        | returns...
                                        |
                                        V
                                    .--------. read()
                                    | IO::   | getline()
                                    | Handle | print()
                                    `--------' etc...

    To illustrate, parsing works this way:

    *   The "parser" parses the MIME stream. A parser is an instance of
        `MIME::Parser'. You hand it an input stream (like a filehandle) to
        parse a message from: if the parse is successful, the result is an
        "entity".

    *   A parsed message is represented by an "entity". An entity is an instance
        of `MIME::Entity' (a subclass of `Mail::Internet'). If the message
        had "parts" (e.g., attachments), then those parts are "entities" as
        well, contained inside the top-level entity. Each entity has a
        "head" and a "body".

    *   The entity's "head" contains information about the message. A "head" is
        an instance of `MIME::Head' (a subclass of `Mail::Header'). It
        contains information from the message header: content type, sender,
        subject line, etc.

    *   The entity's "body" knows where the message data is. You can ask to
        "open" this data source for *reading* or *writing*, and you will get
        back an "I/O handle".

    *   You can open() a "body" and get an "I/O handle" to read/write message
        data. This handle is an object that is basically like an IO::Handle
        or a FileHandle... it can be any class, so long as it supports a
        small, standard set of methods for reading from or writing to the
        underlying data source.

    A typical multipart message containing two parts -- a textual greeting
    and an "attached" GIF file -- would be a tree of MIME::Entity objects,
    each of which would have its own MIME::Head. Like this:

        .--------.
        | MIME:: | Content-type: multipart/mixed
        | Entity | Subject: Happy Samhaine!
        `--------'
             |
             `----.
            parts |
                  |   .--------.
                  |---| MIME:: | Content-type: text/plain; charset=us-ascii
                  |   | Entity | Content-transfer-encoding: 7bit
                  |   `--------'
                  |   .--------.
                  |---| MIME:: | Content-type: image/gif
                      | Entity | Content-transfer-encoding: base64
                      `--------' Content-disposition: inline;
                                   filename="hs.gif"

  Parsing messages

    You usually start by creating an instance of MIME::Parser and setting up
    certain parsing parameters: what directory to save extracted files to,
    how to name the files, etc.

    You then give that instance a readable filehandle on which waits a MIME
    message. If all goes well, you will get back a MIME::Entity object (a
    subclass of Mail::Internet), which consists of...

    *   A MIME::Head (a subclass of Mail::Header) which holds the MIME header
        data.

    *   A MIME::Body, which is a object that knows where the body data is. You
        ask this object to "open" itself for reading, and it will hand you
        back an "I/O handle" for reading the data: this is a FileHandle-like
        object, and could be of any class, so long as it conforms to a
        subset of the IO::Handle interface.

    If the original message was a multipart document, the MIME::Entity
    object will have a non-empty list of "parts", each of which is in turn a
    MIME::Entity (which might also be a multipart entity, etc, etc...).

    Internally, the parser (in MIME::Parser) asks for instances of
    MIME::Decoder whenever it needs to decode an encoded file. MIME::Decoder
    has a mapping from supported encodings (e.g., 'base64') to classes whose
    instances can decode them. You can add to this mapping to try out
    new/experiment encodings. You can also use MIME::Decoder by itself.

  Composing messages

    All message composition is done via the MIME::Entity class. For single-
    part messages, you can use the MIME::Entity/build constructor to create
    MIME entities very easily.

    For multipart messages, you can start by creating a top-level
    `multipart' entity with MIME::Entity::build(), and then use the similar
    MIME::Entity::attach() method to attach parts to that message. *Please
    note:* what most people think of as "a text message with an attached GIF
    file" is *really* a multipart message with 2 parts: the first being the
    text message, and the second being the GIF file.

    When building MIME a entity, you'll have to provide two very important
    pieces of information: the *content type* and the *content transfer
    encoding*. The type is usually easy, as it is directly determined by the
    file format; e.g., an HTML file is `text/html'. The encoding, however,
    is trickier... for example, some HTML files are `7bit'-compliant, but
    others might have very long lines and would need to be sent `quoted-
    printable' for reliability.

    See the section on encoding/decoding for more details, as well as the
    section on "A MIME PRIMER".

  Sending email

    Since MIME::Entity inherits directly from Mail::Internet, you can use
    the normal Mail::Internet mechanisms to send email. For example,

        $entity->smtpsend;

  Encoding/decoding support

    The MIME::Decoder class can be used to *encode* as well; this is done
    when printing MIME entities. All the standard encodings are supported
    (see the section on "A MIME PRIMER" for details):

        Encoding:        | Normally used when message contents are:
        -------------------------------------------------------------------
        7bit             | 7-bit data with under 1000 chars/line, or multipart.
        8bit             | 8-bit data with under 1000 chars/line.
        binary           | 8-bit data with some long lines (or no line breaks).
        quoted-printable | Text files with some 8-bit chars (e.g., Latin-1 text).
        base64           | Binary files.

    Which encoding you choose for a given document depends largely on (1)
    what you know about the document's contents (text vs binary), and (2)
    whether you need the resulting message to have a reliable encoding for
    7-bit Internet email transport.

    In general, only `quoted-printable' and `base64' guarantee reliable
    transport of all data; the other three "no-encoding" encodings simply
    pass the data through, and are only reliable if that data is 7bit ASCII
    with under 1000 characters per line, and has no conflicts with the
    multipart boundaries.

    I've considered making it so that the content-type and encoding can be
    automatically inferred from the file's path, but that seems to be asking
    for trouble... or at least, for Mail::Cap...

  Message-logging

    MIME-tools is a large and complex toolkit which tries to deal with a
    wide variety of external input. It's sometimes helpful to see what's
    really going on behind the scenes. There are several kinds of messages
    logged by the toolkit itself:

    Debug messages
        These are printed directly to the STDERR, with a prefix of `"MIME-
        tools: debug"'.

        Debug message are only logged if you have turned the debugging entry
        elsewhere in this document on in the MIME::Tools configuration.

    Warning messages
        These are logged by the standard Perl warn() mechanism to indicate
        an unusual situation. They all have a prefix of `"MIME-tools:
        warning"'.

        Warning messages are only logged if `$^W' is set true and
        MIME::Tools is not configured to be the quiet entry elsewhere in
        this document .

    Error messages
        These are logged by the standard Perl warn() mechanism to indicate
        that something actually failed. They all have a prefix of `"MIME-
        tools: error"'.

        Error messages are only logged if `$^W' is set true and MIME::Tools
        is not configured to be the quiet entry elsewhere in this document .

    Usage messages
        Unlike "typical" warnings above, which warn about problems
        processing data, usage-warnings are for alerting developers of
        deprecated methods and suspicious invocations.

        Usage messages are currently only logged if `$^W' is set true and
        MIME::Tools is not configured to be the quiet entry elsewhere in
        this document .

    When a MIME::Parser (or one of its internal helper classes) wants to
    report a message, it generally does so by recording the message to the
    MIME::Parser::Results object immediately before invoking the appropriate
    function above. That means each parsing run has its own trace-log which
    can be examined for problems.

  Configuring the toolkit

    If you want to tweak the way this toolkit works (for example, to turn on
    debugging), use the routines in the MIME::Tools module.

    debugging
        Turn debugging on or off. Default is false (off).

             MIME::Tools->debugging(1);

    quiet
        Turn the reporting of warning/error messages on or off. Default is
        true, meaning that these message are silenced.

             MIME::Tools->quiet(1);

    version
        Return the toolkit version.

             print MIME::Tools->version, "\n";

THINGS YOU SHOULD DO
  Take a look at the examples

    The MIME-Tools distribution comes with an "examples" directory. The
    scripts in there are basically just tossed-together, but they'll give
    you some ideas of how to use the parser.

  Run with warnings enabled

    *Always* run your Perl script with `-w'. If you see a warning about a
    deprecated method, change your code ASAP. This will ease upgrades
    tremendously.

  Avoid non-standard encodings

    Don't try to MIME-encode using the non-standard MIME encodings. It's
    just not a good practice if you want people to be able to read your
    messages.

  Plan for thrown exceptions

    For example, if your mail-handling code absolutely must not die, then
    perform mail parsing like this:

        $entity = eval { $parser->parse(\*INPUT) };

    Parsing is a complex process, and some components may throw exceptions
    if seriously-bad things happen. Since "seriously-bad" is in the eye of
    the beholder, you're better off *catching* possible exceptions instead
    of asking me to propagate `undef' up the stack. Use of exceptions in
    reusable modules is one of those religious issues we're never all going
    to agree upon; thankfully, that's what `eval{}' is good for.

  Check the parser results for warnings/errors

    As of 5.3xx, the parser tries extremely hard to give you a MIME::Entity.
    If there were any problems, it logs warnings/errors to the underlying
    "results" object (see the MIME::Parser::Results manpage). Look at that
    object after each parse. Print out the warnings and errors, *especially*
    if messages don't parse the way you thought they would.

  Don't plan on printing exactly what you parsed!

    *Parsing is a (slightly) lossy operation.* Because of things like
    ambiguities in base64-encoding, the following is *not* going to spit out
    its input unchanged in all cases:

        $entity = $parser->parse(\*STDIN);
        $entity->print(\*STDOUT);

    If you're using MIME::Tools to process email, remember to save the data
    you parse if you want to send it on unchanged. This is vital for things
    like PGP-signed email.

  Understand how international characters are represented

    The MIME standard allows for text strings in headers to contain
    characters from any character set, by using special sequences which look
    like this:

        =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?=

    To be consistent with the existing Mail::Field classes, MIME::Tools does
    *not* automatically unencode these strings, since doing so would lose
    the character-set information and interfere with the parsing of fields
    (see the "decode_headers" entry in the MIME::Parser manpage for a full
    explanation). That means you should be prepared to deal with these
    encoded strings.

    The most common question then is, how do I decode these encoded strings?
    The answer depends on what you want to decode them *to*: ASCII, Latin1,
    UTF-8, etc. Be aware that your "target" representation may not support
    all possible character sets you might encounter; for example, Latin1
    (ISO-8859-1) has no way of representing Big5 (Chinese) characters. A
    common practice is to represent "untranslateable" characters as "?"s, or
    to ignore them completely.

    To unencode the strings into some of the more-popular Western byte
    representations (e.g., Latin1, Latin2, etc.), you can use the decoders
    in MIME::WordDecoder (see the MIME::WordDecoder manpage). The simplest
    way is by using `unmime()', a function wrapped around your "default"
    decoder, as follows:

        use MIME::WordDecoder;    
        ...
        $subject = unmime $entity->head->get('subject');

    One place this *is* done automatically is in extracting the recommended
    filename for a part while parsing. That's why you should start by
    setting up the best "default" decoder if the default target of Latin1
    isn't to your liking.

THINGS I DO THAT YOU SHOULD KNOW ABOUT
  Fuzzing of CRLF and newline on input

    RFC-1521 dictates that MIME streams have lines terminated by CRLF
    (`"\r\n"'). However, it is extremely likely that folks will want to
    parse MIME streams where each line ends in the local newline character
    `"\n"' instead.

    An attempt has been made to allow the parser to handle both CRLF and
    newline-terminated input.

  Fuzzing of CRLF and newline when decoding

    The `"7bit"' and `"8bit"' decoders will decode both a `"\n"' and a
    `"\r\n"' end-of-line sequence into a `"\n"'.

    The `"binary"' decoder (default if no encoding specified) still outputs
    stuff verbatim... so a MIME message with CRLFs and no explicit encoding
    will be output as a text file that, on many systems, will have an
    annoying ^M at the end of each line... *but this is as it should be*.

  Fuzzing of CRLF and newline when encoding/composing

    All encoders currently output the end-of-line sequence as a `"\n"', with
    the assumption that the local mail agent will perform the conversion
    from newline to CRLF when sending the mail. However, there probably
    should be an option to output CRLF as per RFC-1521.

  Inability to handle multipart boundaries with embedded newlines

    Let's get something straight: this is an evil, EVIL practice. If your
    mailer creates multipart boundary strings that contain newlines, give it
    two weeks notice and find another one. If your mail robot receives MIME
    mail like this, regard it as syntactically incorrect, which it is.

  Ignoring non-header headers

    People like to hand the parser raw messages straight from POP3 or from a
    mailbox. There is often predictable non-header information in front of
    the real headers; e.g., the initial "From" line in the following
    message:

        From - Wed Mar 22 02:13:18 2000
        Return-Path: <eryq@zeegee.com>
        Subject: Hello

    The parser simply ignores such stuff quietly. Perhaps it shouldn't, but
    most people seem to want that behavior.

  Fuzzing of empty multipart preambles

    Please note that there is currently an ambiguity in the way preambles
    are parsed in. The following message fragments *both* are regarded as
    having an empty preamble (where `\n' indicates a newline character):

         Content-type: multipart/mixed; boundary="xyz"\n
         Subject: This message (#1) has an empty preamble\n
         \n      
         --xyz\n
         ...
          
         Content-type: multipart/mixed; boundary="xyz"\n
         Subject: This message (#2) also has an empty preamble\n
         \n      
         \n
         --xyz\n
         ...

    In both cases, the *first* completely-empty line (after the "Subject")
    marks the end of the header.

    But we should clearly ignore the *second* empty line in message #2,
    since it fills the role of *"the newline which is only there to make
    sure that the boundary is at the beginning of a line"*. Such newlines
    are *never* part of the content preceding the boundary; thus, there is
    no preamble "content" in message #2.

    However, it seems clear that message #1 *also* has no preamble
    "content", and is in fact merely a compact representation of an empty
    preamble.

  Use of a temp file during parsing

    *Why not do everything in core?* Although the amount of core available
    on even a modest home system continues to grow, the size of attachments
    continues to grow with it. I wanted to make sure that even users with
    small systems could deal with decoding multi-megabyte sounds and movie
    files. That means not being core-bound.

    As of the released 5.3xx, MIME::Parser gets by with only one temp file
    open per parser. This temp file provides a sort of infinite scratch
    space for dealing with the current message part. It's fast and
    lightweight, but you should know about it anyway.

  Why do I assume that MIME objects are email objects?

    Achim Bohnet once pointed out that MIME headers do nothing more than
    store a collection of attributes, and thus could be represented as
    objects which don't inherit from Mail::Header.

    I agree in principle, but RFC-1521 says otherwise. RFC-1521 [MIME]
    headers are a syntactic subset of RFC-822 [email] headers. Perhaps a
    better name for these modules would have been RFC1521:: instead of
    MIME::, but we're a little beyond that stage now.

    When I originally wrote these modules for the CPAN, I agonized for a
    long time about whether or not they really should subclass from
    Mail::Internet (then at version 1.17). Thanks to Graham Barr, who
    graciously evolved MailTools 1.06 to be more MIME-friendly, unification
    was achieved at MIME-tools release 2.0. The benefits in reuse alone have
    been substantial.

A MIME PRIMER
    So you need to parse (or create) MIME, but you're not quite up on the
    specifics? No problem...

  Glossary

    Here are some definitions adapted from RFC-1521 explaining the
    terminology we use; each is accompanied by the equivalent in MIME::
    module terms...

    attachment
        An "attachment" is common slang for any part of a multipart message
        -- except, perhaps, for the first part, which normally carries a
        user message describing the attachments that follow (e.g.: "Hey
        dude, here's that GIF file I promised you.").

        In our system, an attachment is just a MIME::Entity under the top-
        level entity, probably one of its parts.

    body
        The "body" of an entity is that portion of the entity which follows
        the header and which contains the real message content. For example,
        if your MIME message has a GIF file attachment, then the body of
        that attachment is the base64-encoded GIF file itself.

        A body is represented by an instance of MIME::Body. You get the body
        of an entity by sending it a bodyhandle() message.

    body part
        One of the parts of the body of a multipart /entity. A body part has
        a /header and a /body, so it makes sense to speak about the body of
        a body part.

        Since a body part is just a kind of entity, it's represented by an
        instance of MIME::Entity.

    entity
        An "entity" means either a /message or a /body part. All entities
        have a /header and a /body.

        An entity is represented by an instance of MIME::Entity. There are
        instance methods for recovering the header (a MIME::Head) and the
        body (a MIME::Body).

    header
        This is the top portion of the MIME message, which contains the
        "Content-type", "Content-transfer-encoding", etc. Every MIME entity
        has a header, represented by an instance of MIME::Head. You get the
        header of an entity by sending it a head() message.

    message
        A "message" generally means the complete (or "top-level") message
        being transferred on a network.

        There currently is no explicit package for "messages"; under MIME::,
        messages are streams of data which may be read in from files or
        filehandles. You can think of the MIME::Entity returned by the
        MIME::Parser as representing the full message.

  Content types

    This indicates what kind of data is in the MIME message, usually as
    *majortype/minortype*. The standard major types are shown below. A more-
    comprehensive listing may be found in RFC-2046.

    application
        Data which does not fit in any of the other categories, particularly
        data to be processed by some type of application program.
        `application/octet-stream', `application/gzip',
        `application/postscript'...

    audio
        Audio data. `audio/basic'...

    image
        Graphics data. `image/gif', `image/jpeg'...

    message
        A message, usually another mail or MIME message. `message/rfc822'...

    multipart
        A message containing other messages. `multipart/mixed',
        `multipart/alternative'...

    text
        Textual data, meant for humans to read. `text/plain', `text/html'...

    video
        Video or video+audio data. `video/mpeg'...

  Content transfer encodings

    This is how the message body is packaged up for safe transit. There are
    the 5 major MIME encodings. A more-comprehensive listing may be found in
    RFC-2045.

    7bit
        No encoding is done at all. This label simply asserts that no 8-bit
        characters are present, and that lines do not exceed 1000 characters
        in length (including the CRLF).

    8bit
        No encoding is done at all. This label simply asserts that the
        message might contain 8-bit characters, and that lines do not exceed
        1000 characters in length (including the CRLF).

    binary
        No encoding is done at all. This label simply asserts that the
        message might contain 8-bit characters, and that lines may exceed
        1000 characters in length. Such messages are the *least* likely to
        get through mail gateways.

    base64
        A standard encoding, which maps arbitrary binary data to the 7bit
        domain. Like "uuencode", but very well-defined. This is how you
        should send essentially binary information (tar files, GIFs, JPEGs,
        etc.).

    quoted-printable
        A standard encoding, which maps arbitrary line-oriented data to the
        7bit domain. Useful for encoding messages which are textual in
        nature, yet which contain non-ASCII characters (e.g., Latin-1,
        Latin-2, or any other 8-bit alphabet).

TERMS AND CONDITIONS
    Eryq (eryq@zeegee.com), ZeeGee Software Inc (http://www.zeegee.com).

    Copyright (c) 1998, 1999 by ZeeGee Software Inc (www.zeegee.com).

    All rights reserved. This program is free software; you can redistribute
    it and/or modify it under the same terms as Perl itself. See the COPYING
    file in the distribution for details.

SUPPORT
    Please email me directly with questions/problems (see AUTHOR below).

    If you want to be placed on an email distribution list (not a mailing
    list!) for MIME-tools, and receive bug reports, patches, and updates as
    to when new MIME-tools releases are planned, just email me and say so.
    If your project is using MIME-tools, it might not be a bad idea to find
    out about those bugs *before* they become problems...

VERSION
    $Revision: 1.1.1.1 $

CHANGE LOG
    Version 5.410   (2000/11/23)
        Better detection of evil filenames. Now we check for filenames which
        are suspiciously long, and a new MIME::Filer::exorcise_filename()
        method is used to try and remove the evil. *Thanks to Jason Haar for
        the suggestion.*

    Version 5.409   (2000/11/12)
        Added functionality to MIME::WordDecoder, including support for
        plain US-ASCII.

        MIME::Tools::tmpopen() made more flexible. You can now override the
        tmpfile-opening behavior.

    Version 5.408   (2000/11/10)
        Added new Beta unmime() mechanism. See the MIME::WordDecoder manpage
        for full details. Also see the section on "Understand how
        international characters are represented".

    Version 5.405   (2000/11/05)
        Added a purge() that does what people want it to. Now, when a parse
        finishes and you want to delete everything that was created by it,
        you can invoke `purge()' on the parser's filer. All
        files/directories created during the last parse should vanish.
        *Thanks to everyone who complained about MIME::Entity::purge.*

    Version 5.404   (2000/11/04)
        Added new automatic MIME-decoding of attachment filenames with
        encoded (non-ASCII) characters. Hopefully this will do more good
        than harm. The use of MIME::Parser::decode_headers() and
        MIME::Head::decode() has been deprecated in favor of the new
        MIME::Words "unmime" mechanism. Please see the "unmime" entry in the
        MIME::Words manpage.

        Added tolerance for unquoted =?...?= in param values. This is in
        violation of the RFCs, but then, so are some MUAs. *Thanks to desti
        for bringing this to my attention.*

        Fixed supposedly-bad B-encoding. *Thanks to Otto Frost for bringing
        this to my attention.*

    Version 5.316   (2000/09/21)
        Increased tolerance in MIME::Parser. Now will ignore bogus POP3
        "+OK" line before header, as well as bogus mailbox "From " line
        (both with warnings). *Thanks to Antony OSullivan (ajos1) for
        suggesting this feature.*

        Fixed small epilogue-related bug in MIME::Entity::print_body(). Now
        it only outputs a final newline if the epilogue does not end in one
        already. Support for checking the preamble/epilogue in regression
        tests was also added. *Thanks to Lars Hecking for bringing this
        issue up.*

        Updated documentation. All module manual pages should now direct
        readers to the main MIME-tools manual page.

    Version 5.314   (2000/09/06)
        Fixed Makefile.PL to have less-restrictive requirement for
        File::Spec (0.6).

    Version 5.313   (2000/09/05)
        Fixed nasty bug with evil filenames. Certain evil filenames were
        getting replaced by internally-generated filenames which were just
        as evil... ouch! If your parser occasionally throws a fatal
        exception with a "write-open" error message, then you have this bug.
        *Thanks to Julian Field and Antony OSullivan (ajos1) for delivering
        the evidence!*

               Beware the doctor
                  who cures seasonal head cold
               by killing patient

        Improved naming of extracted files. If a filename is regarded as
        evil, we guess that it might just be because of part information,
        and attempt to find and use the final path element.

        Simplified message logging and made it more consistent. For details,
        see the section on "Message-logging".

    Version 5.312   (2000/09/03)
        Fixed a Perl 5.7 select() incompatibility which caused "make test"
        to fail. *Thanks to Nick Ing-Simmons for the patch.*

    Version 5.311   (2000/08/16)
        Blind fix for Win32 uudecoding bug. A missing binmode seems to be
        the culprit here; let's see if this fixes it. *Thanks to ajos1 for
        finding the culprit!*

               The carriage return
                  thumbs its nose at me, laughing:
               DOS I/O *still* sucks

    Version 5.310   (2000/08/15)
        Fixed a bug in the back-compat output_prefix() method of
        MIME::Parser. Basically, output prefixes were not being set through
        this mechanism. *Thanks to ajos1 for the alert.*

                shift @_,                               ### "shift at-underscore"
                   or @_ will have
                bogus "self" object

        Added some backcompat methods, like parse_FH(). *Thanks (and
        apologies) to Alain Kotoujansky.*

        Added filenames-with-spaces support to MIME::Decoder::UU. *Thanks to
        Richard Pun for the suggestion.*

    Version 5.305   (2000/07/20)
        Added MIME::Entity::parts_DFS as convenient way to "get all parts".
        *Thanks to Xavier Armengou for suggesting this method.*

        Removed the Alpha notice. Still a few features to tweak, but those
        will be minor.

    Version 5.303   (2000/07/07)
        Fixed output bugs in new Filers. Scads of them: bad handling of
        filename collisions, bad implementation of output_under(), bad
        linking to results, POD errors, you name it. If this had gone to
        CPAN, I'd have issued a factory recall. `:-('

               Errors, like beetles,
                  Multiply ferociously
               In the small hours

    Version 5.301   (2000/07/06)
        READ ME BEFORE UPGRADING PAST THIS POINT! New MIME::Parser::Filer
        class -- not fully backwards-compatible. In response to demand for
        more-comprehensive file-output strategies, I have decided that the
        best thing to do is to split all the file-output logic
        (output_path(), evil_filename(), etc.) into its own separate class,
        inheriting from the new MIME::Parser::Filer class. If you *override*
        any of the following in a MIME::Parser subclass, you will need to
        change your code accordingly:

                evil_filename
                output_dir
                output_filename
                output_path
                output_prefix
                output_under

        My sincere apologies for any inconvenience this will cause, but it's
        ultimately for the best, and is quite likely the last structural
        change to 5.x. *Thanks to Tyson Ackland for all the ideas.*
        Incidentally, the new code also fixes a bug where identically-named
        files in the same message could clobber each other.

               A message arrives:
                   "Here are three files, all named 'Foo'"
               Only one survives.  :-(

        Fixed bug in MIME::Words header decoding. Underscores were not being
        handled properly. *Thanks to Dominique Unruh and Doru Petrescu,* who
        independently submitted the same fix within 2 hours of each other,
        after this bug has lain dormant for months:

               Two users, same bug,
                  same patch -- mere hours apart:
               Truly, life is odd.

        Removed escaping of underscore in regexps. Escaping the underscore
        (\_) in regexps was sloppy and wrong (escaped metacharacters may
        include anything in \w), and the newest Perls warn about it. *Thanks
        to David Dyck for bringing this to my attention.*

               What, then, is a word?
                  Some letters, digits, and, yes:
               Underscores as well

        Added Force option to MIME::Entity's make_multipart. *Thanks to Bob
        Glickstein for suggesting this.*

        Numerous fixlets to example code. *Thanks to Doru Petrescu for
        these.*

        Added REQUIREMENTS section in docs. Long-overdue. *Thanks to Ingo
        Schmiegel for motivating this.*

    Version 5.211   (2000/06/24)
        Fixed auto-uudecode bug. Parser was failing with "part did not end
        with expected boundary" error when uuencoded entity was a
        *singlepart* message (ironically, uuencoded parts of multiparts
        worked fine). *Thanks to Michael Mohlere for testing uudecode and
        finding this.*

               The hurrying bee
                  Flies far for nectar, missing
               The nearest flowers

               Say ten thousand times:
                  Complex cases may succeed
               Where simple ones fail

        Parse errors now generate warnings. Parser errors now cause warn()s
        to be generated if they are not turned into fatal exceptions. This
        might be a little redundant, seeing as they are available in the
        "results", but parser-warnings already cause warn()s. I can always
        put in a "quiet" switch if people complain.

        Miscellaneous cleanup. Documentation of MIME::Parser improved
        slightly, and a redundant warning was removed.

    Version 5.210   (2000/06/20)
        Change in "evil" filename. Made MIME::Parser's evil_filename
        stricter by having it reject "path" characters: any of '/' '\' ':'
        '[' ']'.

               Just as with beauty
                  The eye of the beholder
               Is where "evil" lives.

        Documentation fixes. Corrected a number of docs in MIME::Entity
        which were obsoleted in the transition from 4.x to 5.x. *Thanks to
        Michael Fischer for pointing these out.* For this one, a special 5-
        5-5-5 Haiku of anagrams:

               Documentation
                  in mutant code, O!
               Edit -- no, CUT! [moan]
                  I meant to un-doc...

        IO::Lines usage bug fixed. MIME::Entity was missing a "use
        IO::Lines", which caused an exception when you tried to use the
        body() method of MIME::Entity. *Thanks to Hideyo Imazu and Michael
        Fischer for pointing this out.*

               Bareword looks fine, but
                  Perl cries: "Whoa there... IO::Lines?
               Never heard of it."

    Version 5.209   (2000/06/10)
        Autodetection of uuencode. You can now tell the parser to hunt for
        uuencode inside what should be text parts. See extract_uuencode()
        for full details. Beware: this is largely untested at the moment.
        *Special thanks to Michael Mohlere at ADJE Webmail, who was the
        first -- and most-insistent -- user to request this feature.*

        Faster parsing. Sped up the MIME::Decoder::NBit decoder quite a bit
        by using a variant of the chunking trick I used for
        MIME::Decoder::Base64. I suspect that the same trick (reading a big
        chunk plus the next line to get a big block of lines) would work
        with MIME::Decoder::QuotedPrint, but I don't have the time or
        resources to check that right now (tested contributions would be
        welcome). NBit encoding is more-conveniently done line-by-line for
        now, because individual line lengths must be checked.

        Better use of core. MIME::Body::InCore is now used when you build()
        an entity with the Data parameter, instead of MIME::Body::Scalar.

        More documentation on toolkit configuration.

    Version 5.207   (2000/06/09)
        Fixed whine() bug in MIME::Parser where the "warning" method whine()
        was called as a static function instead of invoked as an instance
        method. *Thanks to Todd A. Bradfute for reporting this.*

               A simple warning
                  Invokes method as function:
               "Warning" makes us die

    Version 5.206   (2000/06/08)
        Ahem. Cough cough:

               Way too many bugs
                  Thus, a self-imposed penance:
               Write haiku for each

        Fixed bug in MIME::Parser: the reader was not handling the odd (but
        legal) case where a multipart boundary is followed by linear
        whitespace. *Thanks to Jon Agnew for reporting this with the RFC
        citation.*

               Legal message fails
                  And 'round the globe, thousands cry:
               READ THE RFC

        Empty preambles are now handled properly by MIME::Entity when
        printing: there is now no space between the header-terminator and
        the initial boundary. *Thanks to "sen_ml" for suggesting this.*

               Nature hates vacuum
                  But please refrain from tossing
               Newlines in the void

        Started using Benchmark for benchmarking.

    Version 5.205   (2000/06/06)
        Added terminating newline to all parser messages, and fixed small
        parser bug that was dropping parts when errors occurred in certain
        places.

    Version 5.203   (2000/06/05)
        Brand new parser based on new (private) MIME::Parser::Reader and
        (public) MIME::Parser::Results. Fast and yet simple and very
        tolerant of bad MIME when desired. Message reporting needs some
        muzzling.

        MIME::Parser now has ignore_errors() set true by default.

    Version 5.116   (2000/05/26)
        Removed Tmpfile.t test, which was causing a bogus failure in "make
        test". Now we require 5.004 for MIME::Parser anyway, so we don't
        need it. *Thanks to Jonathan Cohn for reporting this.*

    Version 5.115   (2000/05/24)
        Fixed Ref.t bug, and documented how to remove parts from a
        MIME::Entity.

    Version 5.114   (2000/05/23)
        Entity now uses MIME::Lite-style default suggested encoding.

        More regression test have been added, and the "Size" tests in Ref.t
        are skipped for text document (due to CRLF differences between
        platforms).

    Version 5.113   (2000/05/21)
        Major speed and structural improvements to the parser. *Major, MAJOR
        thanks to Noel Burton-Krahn, Jeremy Gilbert, and Doru Petrescu for
        all the patches, benchmarking, and Beta-testing!*

        Convenient new one-directory-per-message parsing mechanism. Now
        through `MIME::Parser' method `output_under()', you can tell the
        parser that you want it to create a unique directory for each
        message parsed, to hold the resulting parts.

        Elimination of $', $` and $&. Wow... I still can't believe I missed
        this. D'OH! *Thanks to Noel Burton-Krahn for all his patches.*

        Parser is more tolerant of weird EOL termination. Some mailagents
        are can terminate lines with "\r\r\n". We're okay with that now when
        we extract the header. *Thanks to Joao Fonseca for pointing this
        out.*

        Parser is tolerant of "From " lines in headers. *Thanks to Joachim
        Wieland, Anthony Hinsinger, Marius Stan, and numerous others.*

        Parser catches syntax errors in headers. *Thanks to Russell P.
        Sutherland for catching this.*

        Parser no longer warns when subtype is undefined. *Thanks to Eric-
        Olivier Le Bigot for his fix.*

        Better integration with Mail::Internet. For example, smtpsend()
        should work fine. *Thanks to Michael Fischer and others for the
        patch.*

        Miscellaneous cleanup. *Thanks to Marcus Brinkmann for additional
        helpful input.* *Thanks to Klaus Seidenfaden for good feedback on
        5.x Alpha!*

    Version 4.123   (1999/05/12)
        Cleaned up some of the tests for non-Unix OS'es. Will require a few
        iterations, no doubt.

    Version 4.122   (1999/02/09)
        Resolved CORE::open warnings for 5.005. *Thanks to several folks for
        this bug report.*

    Version 4.121   (1998/06/03)
        Fixed MIME::Words infinite recursion. *Thanks to several folks for
        this bug report.*

    Version 4.117   (1998/05/01)
        Nicer MIME::Entity::build. No longer outputs warnings with undefined
        Filename, and now accepts Charset as well. *Thanks to Jason Tibbits
        III for the inspirational patch.*

        Documentation fixes. Hopefully we've seen the last of the pod2man
        warnings...

        Better test logging. Now uses ExtUtils::TBone.

    Version 4.116   (1998/02/14)
        Bug fix: MIME::Head and MIME::Entity were not downcasing the
        content-type as they claimed. This has now been fixed. *Thanks to
        Rodrigo de Almeida Siqueira for finding this.*

    Version 4.114   (1998/02/12)
        Gzip64-encoding has been improved, and turned off as a default,
        since it depends on having gzip installed. See MIME::Decoder::Gzip64
        if you want to activate it in your app. You can now set up the
        gzip/gunzip commands to use, as well. *Thanks to Paul J. Schinder
        for finding this bug.*

    Version 4.113   (1998/01/20)
        Bug fix: MIME::ParserBase was accidentally folding newlines in
        header fields. *Thanks to Jason L. Tibbitts III for spotting this.*

    Version 4.112   (1998/01/17)
        MIME::Entity::print_body now recurses when printing multipart
        entities, and prints "everything following the header." This is more
        likely what people expect to happen. PLEASE read the "two body
        problem" section of MIME::Entity's docs.

    Version 4.111   (1998/01/14)
        Clean build/test on Win95 using 5.004. Whew.

    Version 4.110   (1998/01/11)
        Added make_multipart() and make_singlepart() in MIME::Entity.

        Improved handling/saving of preamble/epilogue.

    Version 4.109   (1998/01/10)
    Overall Major version shift to 4.x accompanies numerous structural changes,
            and the deletion of some long-deprecated code. Many apologies to
            those who are inconvenienced by the upgrade.

            MIME::IO deprecated. You'll see IO::Scalar, IO::ScalarArray, and
            IO::Wrap to make this toolkit work.

            MIME::Entity deep code. You can now deep-copy MIME entities
            (except for on-disk data files).

    Encoding/decoding
            MIME::Latin1 deprecated, and 8-to-7 mapping removed. Really,
            MIME::Latin1 was one of my more dumber ideas. It's still there,
            but if you want to map 8-bit characters to Latin1 ASCII
            approximations when 7bit encoding, you'll have to request it
            explicitly. *But use quoted-printable for your 8-bit documents;
            that's what it's there for!*

            7bit and 8bit "encoders" no longer encode. As per RFC-2045,
            these just do a pass-through of the data, but they'll warn you
            if you send bad data through.

            MIME::Entity suggests encoding. Now you can ask MIME::Entity's
            build() method to "suggest" a legal encoding based on the body
            and the content-type. No more guesswork! See the "mimesend"
            example.

            New module structure for MIME::Decoder classes. It should be
            easier for you to see what's happening.

            New MIME decoders! Support added for decoding `x-uuencode', and
            for decoding/encoding `x-gzip64'. You'll need "gzip" to make the
            latter work.

            Quoted-printable back on track... and then some. The 'quoted-
            printable' decoder now uses the newest MIME::QuotedPrint, and
            amends its output with guideline #8 from RFC2049 (From/.).
            *Thanks to Denis N. Antonioli for suggesting this.*

    Parsing Preamble and epilogue are now saved. These are saved in the parsed
            entities as simple string-arrays, and are output by print() if
            there. *Thanks to Jason L. Tibbitts for suggesting this.*

            The "multipart/digest" semantics are now preserved. Parts of
            digest messages have their mime_type() defaulted to
            "message/rfc822" instead of "text/plain", as per the RFC.
            *Thanks to Carsten Heyl for suggesting this.*

    Output  Well-defined, more-complete print() output. When printing an entity,
            the output is now well-defined if the entity came from a
            MIME::Parser, even if using parse_nested_messages. See
            MIME::Entity for details.

            You can prevent recommended filenames from being output. This
            possible security hole has been plugged; when building MIME
            entities, you can specify a body path but suppress the filename
            in the header. *Thanks to Jason L. Tibbitts for suggesting
            this.*

    Bug fixes
            Win32 installations should work. The binmode() calls should work
            fine on Win32 now. *Thanks to numerous folks for their patches.*

            MIME::Head::add() now no longer downcases its argument. *Thanks
            to Brandon Browning & Jason L. Tibbitts for finding this bug.*

    Version 3.204
        Bug in MIME::Head::original_text fixed. Well, it took a while, but
        another bug surfaced from my transition from 1.x to 2.x. This method
        was, quite idiotically, sorting the header fields. *Thanks, as
        usual, to Andreas Koenig for spotting this one.*

        MIME::ParserBase no longer defaults to RFC-1522-decoding headers.
        The documentation correctly stated that the default setting was to
        *not* RFC-1522-decode the headers. The code, on the other hand, was
        init'ing this parser option in the "on" position. This has been
        fixed.

        MIME::ParserBase::parse_nested_messages reexamined. If you use this
        feature, please re-read the documentation. It explains a little more
        precisely what the ramifications are.

        MIME::Entity tries harder to ensure MIME compliance. It is now a
        fatal error to use certain bad combinations of content type and
        encoding when "building", or to attempt to "attach" to anything that
        is not a multipart document. My apologies if this inconveniences
        anyone, but it was just too darn easy before for folks to create bad
        MIME, and gosh darn it, good libraries should at least *try* to
        protect you from mistakes.

        The "make" now halts if you don't have the right stuff, provided
        your MakeMaker supports PREREQ_PM. See the section on "REQUIREMENTS"
        for what you need to install this package. I still provide old
        courtesy copies of the MIME:: decoding modules. *Thanks to Hugo van
        der Sanden for suggesting this.*

        The "make test" is far less chatty. Okay, okay, STDERR is evil. Now
        a `"make test"' will just give you the important stuff: do a `"make
        test TEST_VERBOSE=1"' if you want the gory details (advisable if
        sending me a bug report). *Thanks to Andreas Koenig for suggesting
        this.*

    Version 3.203
        No, there haven't been any major changes between 2.x and 3.x. The
        major-version increase was from a few more tweaks to get $VERSION to
        be calculated better and more efficiently (I had been using RCS
        version numbers in a way which created problems for users of
        CPAN::). After a couple of false starts, all modules have been
        upgraded to RCS 3.201 or higher.

        You can now parse a MIME message from a scalar, an array-of-scalars,
        or any MIME::IO-compliant object (including IO:: objects.) Take a
        look at parse_data() in MIME::ParserBase. The parser code has been
        modified to support the MIME::IO interface. *Thanks to fellow
        Chicagoan Tim Pierce (and countless others) for asking.*

        More sensible toolkit configuration. A new config() method in
        MIME::ToolUtils makes a lot of toolkit-wide configuration cleaner.
        Your old calls will still work, but with deprecation warnings.

        You can now sign messages just like in Mail::Internet. See
        MIME::Entity for the interface.

        You can now remove signatures from messages just like in
        Mail::Internet. See MIME::Entity for the interface.

        You can now compute/strip content lengths and other non-standard
        MIME fields. See sync_headers() in MIME::Entity. *Thanks to Tim
        Pierce for bringing the basic problem to my attention.*

        Many warnings are now silent unless $^W is true. That means unless
        you run your Perl with `-w', you won't see deprecation warnings,
        non-fatal-error messages, etc. But of course you run with `-w', so
        this doesn't affect you. `:-)'

        Completed the 7-bit encodings in MIME::Latin1. We hadn't had
        complete coverage in the conversion from 8- to 7-bit; now we do.
        *Thanks to Rolf Nelson for bringing this to my attention.*

        Fixed broken parse_two() in MIME::ParserBase. BTW, if your code
        worked with the "broken" code, it should *still* work. *Thanks again
        to Tim Pierce for bringing this to my attention.*

    Version 2.14
        Just a few bug fixes to improve compatibility with Mail-Tools 1.08,
        and with the upcoming Perl 5.004 release. *Thanks to Jason L.
        Tibbitts III for reporting the problems so quickly.*

    Version 2.13
    New features
            Added RFC-1522-style decoding of encoded header fields. Header
            decoding can now be done automatically during parsing via the
            new `decode()' method in MIME::Head... just tell your parser
            object that you want to `decode_headers()'. *Thanks to Kent
            Boortz for providing the idea, and the baseline RFC-1522-
            decoding code!*

            Building MIME messages is even easier. Now, when you use
            MIME::Entity's `build()' or `attach()', you can also supply
            individual mail headers to set (e.g., `-Subject', `-From', `-
            To').

            Added `Disposition' to MIME::Entity's `build()' method. *Thanks
            to Kurt Freytag for suggesting this feature.*

            An `X-Mailer' header is now output by default in all MIME-
            Entity-prepared messages, so any bad MIME we generate can be
            traced back to this toolkit.

            Added `purge()' method to MIME::Entity for deleteing leftover
            files. *Thanks to Jason L. Tibbitts III for suggesting this
            feature.*

            Added `seek()' and `tell()' methods to built-in MIME::IO
            classes. Only guaranteed to work when reading! *Thanks to Jason
            L. Tibbitts III for suggesting this feature.*

            When parsing a multipart message with apparently no boundaries,
            the error message you get has been improved. *Thanks to Andreas
            Koenig for suggesting this.*

    Bug fixes
            Patched over a Perl 5.002 (and maybe earlier and later) bug
            involving FileHandle::new_tmpfile. It seems that the underlying
            filehandles were not being closed when the FileHandle objects
            went out of scope! There is now an internal routine that creates
            true FileHandle objects for anonymous temp files. *Thanks to
            Dragomir R. Radev and Zyx for reporting the weird behavior that
            led to the discovery of this bug.*

            MIME::Entity's `build()' method now warns you if you give it an
            illegal boundary string, and substitutes one of its own.

            MIME::Entity's `build()' method now generates safer, fully-RFC-
            1521-compliant boundary strings.

            Bug in MIME::Decoder's `install()' method was fixed. *Thanks to
            Rolf Nelson and Nickolay Saukh for finding this.*

            Changed FileHandle::new_tmpfile to FileHandle->new_tmpfile, so
            some Perl installations will be happier. *Thanks to Larry W.
            Virden for finding this bug.*

            Gave `=over' an arg of 4 in all PODs. *Thanks to Larry W. Virden
            for pointing out the problems of bare =over's*

    Version 2.04
        A bug in MIME::Entity's output method was corrected.
        MIME::Entity::print now outputs everything to the desired filehandle
        explicitly. *Thanks to Jake Morrison for pointing out the
        incompatibility with Mail::Header.*

    Version 2.03
        Fixed bug in autogenerated filenames resulting from transposed "if"
        statement in MIME::Parser, removing spurious printing of header as
        well. (Annoyingly, this bug is invisible if debugging is turned on!)
        *Thanks to Andreas Koenig for bringing this to my attention.*

        Fixed bug in MIME::Entity::body() where it was using the bodyhandle
        completely incorrectly. *Thanks to Joel Noble for bringing this to
        my attention.*

        Fixed MIME::Head::VERSION so CPAN:: is happier. *Thanks to Larry
        Virden for bringing this to my attention.*

        Fixed undefined-variable warnings when dumping skeleton (happened
        when there was no Subject: line) *Thanks to Joel Noble for bringing
        this to my attention.*

    Version 2.02
        Stupid, stupid bugs in both BASE64 encoding and decoding were fixed.
        *Thanks to Phil Abercrombie for locating them.*

    Version 2.01
        Modules now inherit from the new Mail:: modules! This means big
        changes in behavior.

        MIME::Parser can now store message data in-core. There were a *lot*
        of requests for this feature.

        MIME::Entity can now compose messages. There were a *lot* of
        requests for this feature.

        Added option to parse `"message/rfc822"' as a pseduo-multipart
        document. *Thanks to Andreas Koenig for suggesting this.*

    Version 1.13
        MIME::Head now no longer requires space after ":", although either a
        space or a tab after the ":" will be swallowed if there. *Thanks to
        Igor Starovoitov for pointing out this shortcoming.*

    Version 1.12
        Fixed bugs in parser where CRLF-terminated lines were blowing out
        the handling of preambles/epilogues. *Thanks to Russell Sutherland
        for reporting this bug.*

        Fixed idiotic is_multipart() bug. *Thanks to Andreas Koenig for
        noticing it.*

        Added untested binmode() calls to parser for DOS, etc. systems. No
        idea if this will work...

        Reorganized the output_path() methods to allow easy use of
        inheritance, as per Achim Bohnet's suggestion.

        Changed MIME::Head to report mime_type more accurately.

        POSIX module no longer loaded by Parser if perl >= 5.002. Hey,
        5.001'ers: let me know if this breaks stuff, okay?

        Added unsupported ./examples directory.

    Version 1.11
        Converted over to using Makefile.PL. *Thanks to Andreas Koenig for
        the much-needed kick in the pants...*

        Added t/*.t files for testing. Eeeeeeeeeeeh...it's a start.

        Fixed bug in default parsing routine for generating output paths; it
        was warning about evil filenames if there simply *were* no
        recommended filenames. D'oh!

        Fixed redefined parts() method in Entity.

        Fixed bugs in Head where field name wasn't being case folded.

    Version 1.10
        A typo was causing the epilogue of an inner multipart message to be
        swallowed to the end of the OUTER multipart message; this has now
        been fixed. *Thanks to Igor Starovoitov for reporting this bug.*

        A bad regexp for parameter names was causing some parameters to be
        parsed incorrectly; this has also been fixed. *Thanks again to Igor
        Starovoitov for reporting this bug.*

        It is now possible to get full control of the filenaming algorithm
        before output files are generated, and the default algorithm is
        safer. *Thanks to Laurent Amon for pointing out the problems, and
        suggesting some solutions.*

        Fixed illegal "simple" multipart test file. D'OH!

    Version 1.9
        No changes: 1.8 failed CPAN registration

    Version 1.8
        Fixed incompatibility with 5.001 and FileHandle::new_tmpfile Added
        COPYING file, and improved README.

AUTHOR
    MIME-tools was created by:

        ___  _ _ _   _  ___ _
       / _ \| '_| | | |/ _ ' /    Eryq, (eryq@zeegee.com)
      |  __/| | | |_| | |_| |     President, ZeeGee Software Inc.
       \___||_|  \__, |\__, |__   http://www.zeegee.com/
                 |___/    |___/

    Released as MIME-parser (1.0): 28 April 1996. Released as MIME-tools
    (2.0): Halloween 1996. Released as MIME-tools (4.0): Christmas 1997.
    Released as MIME-tools (5.0): Mother's Day 2000.

ACKNOWLEDGMENTS
    This kit would not have been possible but for the direct contributions
    of the following:

        Gisle Aas             The MIME encoding/decoding modules.
        Laurent Amon          Bug reports and suggestions.
        Graham Barr           The new MailTools.
        Achim Bohnet          Numerous good suggestions, including the I/O model.
        Kent Boortz           Initial code for RFC-1522-decoding of MIME headers.
        Andreas Koenig        Numerous good ideas, tons of beta testing,
                                and help with CPAN-friendly packaging.
        Igor Starovoitov      Bug reports and suggestions.
        Jason L Tibbitts III  Bug reports, suggestions, patches.

    Not to mention the Accidental Beta Test Team, whose bug reports (and
    comments) have been invaluable in improving the whole:

        Phil Abercrombie
        Mike Blazer
        Brandon Browning
        Kurt Freytag
        Steve Kilbane
        Jake Morrison
        Rolf Nelson
        Joel Noble
        Michael W. Normandin
        Tim Pierce
        Andrew Pimlott
        Dragomir R. Radev
        Nickolay Saukh
        Russell Sutherland
        Larry Virden
        Zyx

    Please forgive me if I've accidentally left you out. Better yet, email
    me, and I'll put you in.

SEE ALSO
    At the time of this writing ($Date: 2001-03-29 23:55:41 $), the MIME-
    tools homepage was http://www.zeegee.com/code/perl/MIME-tools. Check
    there for updates and support.

    Users of this toolkit may wish to read the documentation of Mail::Header
    and Mail::Internet.

    The MIME format is documented in RFCs 1521-1522, and more recently in
    RFCs 2045-2049.

    The MIME header format is an outgrowth of the mail header format
    documented in RFC 822.

