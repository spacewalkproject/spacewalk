#!/usr/bin/python

import logging, os, re, sys, xmlrpclib
from cmd import Cmd
from getpass import getpass
from optparse import Option, OptionParser
from pwd import getpwuid

sys.path.append(os.getcwd())
#from spacewalk_shell_actions import *

class SpacewalkShell(Cmd):
    MINIMUM_API_VERSION = 10.8
   
    def __init__(self, options):
        # set some defaults since we can't call our superclass constructor
        self.cmdqueue = []
        self.completekey = "tab"
        self.stdout = sys.stdout
        
        self.prompt = 'Spacewalk> '
       
        try:
            # don't split on hyphens during tab completion
            import readline
            newdelims = readline.get_completer_delims().replace('-', '')
            readline.set_completer_delims(newdelims)
        except:
            pass

        self.session = ''

        # make the options available everywhere
        self.options = options

        userinfo = getpwuid(os.getuid())
        self.cache_file = os.path.join(userinfo[5], ".spacewalk_cache")
        self.history_file = os.path.join(userinfo[5], ".spacewalk_history")

 
    # write the history file and exit 
    def terminate(self, exit_code=0):
        print

        if not self.options.nohistory:
            try:
                import readline
                readline.write_history_file(self.history_file)
            except:
                logging.error("Could not write history file")

        sys.exit(exit_code)

 
    def emptyline(self):
        pass


    # load the history file
    def preloop(self):
        if not options.nohistory:
            try:
                import readline
                readline.read_history_file(self.history_file)
            except:
                logging.error("Could not read history file")

        if not self.session:
            self.args = []
            self.do_login(self.args)


    # handle commands that exit the shell
    def precmd(self, line):
        # set the command and arguments once so they can be used elsewhere
        try:
            parts = line.split()
            self.cmd = parts[0]
            self.args = parts[1:]
        except IndexError:
            self.cmd = ''
            self.args = []
 
        if self.cmd.lower() in ('quit', 'exit', 'eof'):
            self.terminate()
        else:
            return line

###########

    def tab_completer(self, options, text):
        return [x for x in options if x.startswith(text)]
    
    def filter_results(self, list, args):
        patterns = []
        for pattern in args:
            patterns.append(re.compile(pattern, re.IGNORECASE))

        matches = []
        for item in list:
            if len(patterns) > 0:
                for pattern in patterns:
                    if pattern.search(item):
                        matches.append(item)
            else:
                matches.append(item)

        matches.sort()
        return matches

###########

    def help_help(self):
        print "help COMMAND"

###########

    def help_login(self):
        print "login [USERNAME] [SERVER]"

    def do_login(self, args):
        self.session = ''
        
        if self.options.nossl:
            proto = "http"
        else:
            proto = "https"

        if len(self.args) == 2 and self.args[1]:
            server = self.args[1]
        elif self.options.server:
            server = self.options.server
        else:
            logging.error("No server specified")
            return

        server = proto + "://" + server + "/rpc/api"

        # connect to the server
        logging.debug("Connecting to " + server)
        self.client = xmlrpclib.Server(server)

        try:
            api_version = self.client.api.getVersion()
        except:
            logging.error(sys.exc_info()[1])
            self.client = None
            return

        # ensure the server is recent enough
        if api_version < self.MINIMUM_API_VERSION:
            logging.error("API (" + api_version + ") is too old (>= " \
                         + self.MINIMUM_API_VERSION + " required)")

            self.client = None
            return

        # retrieve a cached session
        if not self.options.nocache:
            if os.path.isfile(self.cache_file):
                try:
                    # read the session (format = username:session)
                    sessionfile = open(self.cache_file, "r")
                    parts = sessionfile.read().split(':')
                    sessionfile.close()
   
                    username = parts[0]
                    self.session = parts[1]
                except:
                    logging.error("Could not read " + self.cache_file)

                try:
                    logging.info("Using cached credentials from " + \
                                 self.cache_file)

                    self.client.user.listUsers(self.session)
                except:
                    logging.warning("Cached credentials are invalid")
                    self.session = ''
                    os.remove(self.cache_file)
        
        # attempt to login if we don't have a valid session yet    
        if not self.session:
            if self.options.username:
                username = self.options.username
                self.options.username = None
            elif len(self.args) > 0 and self.args[0]:
                username = self.args[0]
            else:
                username = raw_input("Username: ")

            if self.options.password:
                password = self.options.password
                self.options.password = None
            else:
                password = getpass("Password: ")

            try:
                self.session = self.client.auth.login(username, 
                                                      password)
            except:
                logging.error("Invalid credentials")
                return

            # write the session to a cache
            if not self.options.nocache:
                try:
                    logging.debug("Writing session cache to " + self.cache_file) 
                    sessionfile = open(self.cache_file, "w")
                    sessionfile.write(username + ':' + self.session)
                    sessionfile.close()
                except:
                    logging.error("Could not write cache file")
 
        # disable caching of subsequent logins
        self.options.nocache = True

        logging.info("Connected to " + server + " as " + username)

###########

    def help_logout(self):
        print "logout"
        
    def do_logout(self, args):
        if self.session:
            self.client.auth.logout(self.session)
            self.session = ''
        else:
            logging.error("You're not logged in")

###########

    def help_getapi(self):
        print "getapi"


    def do_getapi(self, args):
        print self.client.api.getVersion()

###########

    def help_getsystemversion(self):
        print "getsystemversion"

    def do_getsystemversion(self, args):
        print self.client.api.systemVersion()

###########

    def help_getcertificateexpiration(self):
        print "getcertificateexpiration"

    def do_getcertificateexpiration(self, args):
        print self.client.satellite.getCertificateExpirationDate(self.session).value

###########

    def help_listentitlements(self):
        print "listentitlements"

    def do_listentitlements(self, args):
        entitlements = self.client.satellite.listEntitlements(self.session)

        print "System:"
        for e in entitlements.get('system'):
            print e.get('label') + ": " + \
                  str(e.get('used_slots')) + "/" + str(e.get('total_slots'))

        print       
 
        print "Channel:"
        for e in entitlements.get('channel'):
            print e.get('label') + ": " + \
                  str(e.get('used_slots')) + "/" + str(e.get('total_slots'))

###########

    def help_listsystems(self):
        print "listsystems [PATTERN1] [PATTERN2] ..."
    
    def do_listsystems(self, args, doreturn=0):
        systems = self.client.system.listSystems(self.session)
        systems = [x.get('name') for x in systems]

        if doreturn:
            return systems
        else:
            print "\n".join(self.filter_results(systems, self.args))

###########

    def help_getsystemdetails(self):
        print "getsystemdetails SYSTEM"

    def complete_getsystemdetails(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_listsystems('', 1), text)
 
    def do_getsystemdetails(self, args):
        if len(self.args) != 1:
            self.help_getsystemdetails()
            return

        try:
            try:
                # check if we were passed a system ID
                system_id = int(self.args[0])
    
                system = self.client.system.getName(self.session, system_id)
                last_checkin = system.get('last_checkin')
            except ValueError:
                system_id = None

            if not system_id:
                systems = self.client.system.getId(self.session,
                                                   self.args[0])

                if len(systems) > 1:
                    logging.info("Multiple systems found with the same name")

                    for system in systems:
                        logging.info(self.args[0] + " = " + system.get('id')) 

                    return

                system_id = systems[0].get('id')
                last_checkin = systems[0].get('last_checkin')

            details = self.client.system.getDetails(self.session, system_id)

            registered = self.client.system.getRegistrationDate(self.session,
                                                                system_id)

            entitlements = self.client.system.getEntitlements(self.session,
                                                              system_id)

            base_channel = \
                self.client.system.getSubscribedBaseChannel(self.session,
                                                            system_id)

            child_channels = \
                self.client.system.listSubscribedChildChannels(self.session,
                                                               system_id)

            groups = self.client.system.listGroups(self.session,
                                                   system_id)

            kernel = self.client.system.getRunningKernel(self.session,
                                                         system_id)
        except xmlrpclib.Fault, err:
            logging.error(err.faultString.rsplit(': ', 1)[1])
            return 
        except:
            logging.debug(sys.exc_info()[0])
            logging.error("Could not retreive system information")
            return
       
        print "Name:          " + self.args[0] + "\n" + \
              "System ID:     " + str(system_id) + "\n" + \
              "Locked:        " + str(details.get('lock_status')) + "\n" + \
              "Registered:    " + registered.value + "\n" + \
              "Last Checkin:  " + last_checkin.value + "\n" + \
              "Kernel:        " + kernel + "\n" + \
              "Base Channel:  " + base_channel.get('label')

        for channel in child_channels:
            print "Child Channel: " + channel.get('label')

        for entitlement in entitlements:
            print "Entitlement:   " + entitlement

        for group in groups:
            if group.get('subscribed') == 1:
                print "Group:         " + group.get('system_group_name')

###########

    def help_listswchannels(self):
        print "listswchannels [PATTERN1] [PATTERN2] ..."

    def do_listswchannels(self, args, doreturn=0):
        channels = self.client.channel.listAllChannels(self.session)
        channels = [x.get('label') for x in channels]

        if doreturn:
            return channels
        else:
            print "\n".join(self.filter_results(channels, self.args))
      
###########
 
    def help_getswchanneldetails(self):
        print "getswchanneldetails CHANNEL"

    def complete_getswchanneldetails(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_listswchannels('', 1), text)
 
    def do_getswchanneldetails(self, args):
        if len(self.args) != 1:
            self.help_getswchanneldetails()
            return

        try:
            details = self.client.channel.software.getDetails(self.session, 
                                                              self.args[0])
        except xmlrpclib.Fault, err:
            logging.error(err.faultString.rsplit(': ', 1)[1])
            return 
       
        print "Label:           " + details.get('label') + "\n" + \
              "Name:            " + details.get('name') + "\n" + \
              "Parent:          " + details.get('parent_channel_label') + "\n" + \
              "Architecture:    " + details.get('arch_name') + "\n" + \
              "GPG Key:         " + details.get('gpg_key_id') + "\n" + \
              "GPG Fingerprint: " + details.get('gpg_key_fp') + "\n" + \
              "GPG URL:         " + details.get('gpg_key_url')

###########

# parse the options and then start the command interpreter
if __name__ == "__main__":
    optionsTable = [
        Option('-u', '--username', action='store',
               help='Use this username to connect to RHN/Satellite'),
        Option('-p', '--password', action='store',
               help='Use this password to connect to RHN/Satellite'),
        Option('--server', action='store', default="localhost", 
               help='Connect to this server (http[s]://<hostname>/APP)'),
        Option('--nocache', action='store_true',
                help="Do not create a username/password cache"),
        Option('--nossl', action='store_true',
               help="Use HTTP instead of HTTPS"),
        Option('--nohistory', action='store_true',
                help="Do not store command history in ~/.spacewalk_history"),
        Option('-d', '--debug', action='store_true',
               help="Enable debug logging"),
    ]
    
    parser = OptionParser(option_list=optionsTable)
    (options, args) = parser.parse_args()
 
    if options.debug:
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO


    # setup logging
    logging.basicConfig(level=log_level, 
                        format="%(levelname)s: %(message)s")

    # setup the shell
    shell = SpacewalkShell(options)

    # start the shell
    while 1:
        try:
            shell.cmdloop()
        except xmlrpclib.Fault, err:
            logging.error(err.faultString.rsplit(': ', 1)[1])
        except KeyboardInterrupt:
            shell.terminate()

# vim:ts=4:expandtab:
