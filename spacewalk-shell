#!/usr/bin/python

import logging, os, re, sys, textwrap, xmlrpclib
from cmd import Cmd
from getpass import getpass
from optparse import Option, OptionParser
from pwd import getpwuid

class SpacewalkShell(Cmd):
    MINIMUM_API_VERSION = 10.8
  
    ENTITLEMENTS = {'provisioning_entitled'        : 'Provisioning',
                    'enterprise_entitled'          : 'Management',
                    'monitoring_entitled'          : 'Monitoring',
                    'virtualization_host'          : 'Virtualization',
                    'virtualization_host_platform' : 'Virtualization Platform'}
 
    def __init__(self, options):
        # set some defaults since we can't call our superclass constructor
        self.cmdqueue = []
        self.completekey = "tab"
        self.stdout = sys.stdout
        
        self.prompt = 'Spacewalk> '
       
        try:
            # don't split on hyphens during tab completion
            import readline
            newdelims = readline.get_completer_delims().replace('-', '')
            readline.set_completer_delims(newdelims)
        except:
            pass

        self.session = ''
        self.ssm = {}

        # make the options available everywhere
        self.options = options

        userinfo = getpwuid(os.getuid())
        self.cache_file = os.path.join(userinfo[5], ".spacewalk_cache")
        self.history_file = os.path.join(userinfo[5], ".spacewalk_history")

 
    # write the history file and exit 
    def terminate(self, exit_code=0):
        print

        if not self.options.nohistory:
            try:
                import readline
                readline.write_history_file(self.history_file)
            except:
                logging.error("Could not write history file")

        sys.exit(exit_code)

 
    def emptyline(self):
        pass


    # load the history file
    def preloop(self):
        if not options.nohistory:
            try:
                import readline
                readline.read_history_file(self.history_file)
            except:
                logging.error("Could not read history file")

        if not self.session:
            self.args = []
            self.do_login(self.args)


    # handle commands that exit the shell
    def precmd(self, line):
        # set the command and arguments once so they can be used elsewhere
        try:
            parts = line.split()
            self.cmd = parts[0]
            self.args = parts[1:]
        except IndexError:
            self.cmd = ''
            self.args = []
 
        if self.cmd.lower() in ('quit', 'exit', 'eof'):
            self.terminate()
        else:
            return line

###########

    def tab_completer(self, options, text):
        return [o for o in options if o.startswith(text)]
    
    def filter_results(self, list, args):
        patterns = []
        for pattern in args:
            patterns.append(re.compile(pattern, re.IGNORECASE))

        matches = []
        for item in list:
            if len(patterns) > 0:
                for pattern in patterns:
                    if pattern.search(item):
                        matches.append(item)
            else:
                matches.append(item)

        matches.sort()
        return matches

    def build_package_names(self, packages):
        new_packages = []
        for p in packages:
            package = p.get('name') + '-' \
                    + p.get('version') + '-' \
                    + p.get('release')

            if p.get('epoch') != ' ' and p.get('epoch') != '':
                package = package + ':' + p.get('epoch')

            if p.get('arch'):
                package = package + '.' + p.get('arch')
            elif p.get('arch_label'):
                package = package + '.' + p.get('arch_label')

            new_packages.append(package)
           
        packages = new_packages
        packages.sort()

        return packages

    def get_system_id(self, name):
        systems = self.client.system.getId(self.session, name)

        if len(systems) == 0:
            logging.error("No systems found")
            return
        elif len(systems) == 1:
            return systems[0].get('id')
        else:
            logging.warning("Multiple systems found with the same name")

            for system in systems:
                logging.warning(name + " = " + str(system.get('id'))) 

            return

###########

    def help_addtossm(self):
        print "Usage: addtossm SYSTEM1 [SYSTEM2] ..."

    def complete_addtossm(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_listsystems('', True, False), text)

    def do_addtossm(self, args):
        all_systems = {}
        for s in self.client.system.listSystems(self.session):
            all_systems[s.get('name')] = s.get('id')

        matches = self.filter_results(all_systems.keys(), self.args)

        if len(matches) == 0:
            logging.warning("No systems found")
            return

        for match in matches:
            if match in self.ssm.keys():
                logging.warning(match + " is already in the SSM")
                continue
            else:             
                logging.info("Added " + match + " to the SSM")
                logging.debug("System ID: " + str(all_systems.get(match)))
                self.ssm[match] = all_systems.get(match)


    def help_delfromssm(self):
        print "Usage: delfromssm SYSTEM1 [SYSTEM2] ..."
    
    def complete_delfromssm(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_listssm('', True), text)

    def do_delfromssm(self, args):
        matches = self.filter_results(self.ssm.keys(), self.args)
        
        if len(matches) == 0:
            logging.warning("No matches found in the SSM")
            return

        for match in matches:
            logging.info("Deleting " + match + " from the SSM")
            del self.ssm[match]
            
 
    def help_listssm(self):
        print "Usage: listssm"
    
    def do_listssm(self, args, doreturn=False):
        systems = sorted(self.ssm.keys())

        if doreturn:
            return systems
        else:
            for s in systems:
                print s


    def help_clearssm(self):
        print "Usage: clearssm"
    
    def do_clearssm(self, args):
        self.ssm.clear()

###########

    def help_help(self):
        print "Usage: help COMMAND"

    def help_clear(self):
        print "Usage: clear"
    
    def do_clear(self, args):
        os.system('clear')

###########

    def help_login(self):
        print "Usage: login [USERNAME] [SERVER]"

    def do_login(self, args):
        self.session = ''
        
        if self.options.nossl:
            proto = "http"
        else:
            proto = "https"

        if len(self.args) == 2 and self.args[1]:
            server = self.args[1]
        elif self.options.server:
            server = self.options.server
        else:
            logging.error("No server specified")
            return

        server = proto + "://" + server + "/rpc/api"

        # connect to the server
        logging.debug("Connecting to " + server)
        self.client = xmlrpclib.Server(server)

        try:
            api_version = self.client.api.getVersion()
        except:
            logging.error(sys.exc_info()[1])
            self.client = None
            return

        # ensure the server is recent enough
        if api_version < self.MINIMUM_API_VERSION:
            logging.error("API (" + api_version + ") is too old (>= " \
                         + self.MINIMUM_API_VERSION + " required)")

            self.client = None
            return

        # retrieve a cached session
        if not self.options.nocache:
            if os.path.isfile(self.cache_file):
                try:
                    # read the session (format = username:session)
                    sessionfile = open(self.cache_file, "r")
                    parts = sessionfile.read().split(':')
                    sessionfile.close()
   
                    username = parts[0]
                    self.session = parts[1]
                except:
                    logging.error("Could not read " + self.cache_file)

                try:
                    logging.info("Using cached credentials from " + \
                                 self.cache_file)

                    self.client.user.listUsers(self.session)
                except:
                    logging.warning("Cached credentials are invalid")
                    self.session = ''

                    try:
                        os.remove(self.cache_file)
                    except:
                        pass
        
        # attempt to login if we don't have a valid session yet    
        if not self.session:
            if self.options.username:
                username = self.options.username
                self.options.username = None
            elif len(self.args) > 0 and self.args[0]:
                username = self.args[0]
            else:
                username = raw_input("Username: ")

            if self.options.password:
                password = self.options.password
                self.options.password = None
            else:
                password = getpass("Password: ")

            try:
                self.session = self.client.auth.login(username, 
                                                      password)
            except:
                logging.error("Invalid credentials")
                return

            # write the session to a cache
            if not self.options.nocache:
                try:
                    logging.debug("Writing session cache to " + self.cache_file) 
                    sessionfile = open(self.cache_file, "w")
                    sessionfile.write(username + ':' + self.session)
                    sessionfile.close()
                except:
                    logging.error("Could not write cache file")
 
        # disable caching of subsequent logins
        self.options.nocache = True

        logging.info("Connected to " + server + " as " + username)

###########

    def help_logout(self):
        print "Usage: logout"
        
    def do_logout(self, args):
        if self.session:
            self.client.auth.logout(self.session)
            self.session = ''
            
            try:
                os.remove(self.cache_file)
            except:
                pass
        else:
            logging.error("You're not logged in")

###########

    def help_getapiversion(self):
        print "Usage: getapiversion"


    def do_getapiversion(self, args):
        print self.client.api.getVersion()

###########

    def help_getserverversion(self):
        print "Usage: getserverversion"

    def do_getserverversion(self, args):
        print self.client.api.systemVersion()

###########

    def help_getcertificateexpiration(self):
        print "Usage: getcertificateexpiration"

    def do_getcertificateexpiration(self, args):
        print self.client.satellite.getCertificateExpirationDate(self.session).value

###########

    def help_listentitlements(self):
        print "Usage: listentitlements"

    def do_listentitlements(self, args):
        entitlements = self.client.satellite.listEntitlements(self.session)

        print "System:"
        for e in entitlements.get('system'):
            print e.get('label') + ": " + \
                  str(e.get('used_slots')) + "/" + str(e.get('total_slots'))

        print       
 
        print "Channel:"
        for e in entitlements.get('channel'):
            print e.get('label') + ": " + \
                  str(e.get('used_slots')) + "/" + str(e.get('total_slots'))

###########

    def help_getpackagedetails(self):
        print "Usage: getpackagedetails PACKAGE1 [PACKAGE2] ..."        

    def do_getpackagedetails(self, args):
        add_separator = False

        for package in self.args:
            if add_separator:
                print
                print "--------------------"
                print

            add_separator = True

            try:
                id = int(package)
            except:
                id = self.client.packages.search.name(self.session,
                                                      package)[0].get('id')

            details = self.client.packages.getDetails(self.session, id)
            channels = self.client.packages.listProvidingChannels(self.session,
                                                                  id)

            print "Name:    " + details.get('name')
            print "Version: " + details.get('version')
            print "Release: " + details.get('release') 
            print "Epoch:   " + details.get('epoch') or "N/A"
            print "Arch:    " + details.get('arch_label')

            print
            print "Description: "
            for line in textwrap.wrap(details.get('description')):
                print line

            print
            print "File:    " + details.get('file')
            print "Size:    " + details.get('size')
            print "MD5:     " + details.get('md5sum')

            print
            print "Available From:"
            for channel in sorted([c.get('label') for c in channels]):
                print channel

###########

    def help_findpackages(self):
        print "Usage: findpackages QUERY"
        print "Available Fields: name, epoch, version, release, arch, " + \
              "description, summary"
        print "Example: name:kernel AND version:2.6.18 AND -description:devel" 

    def do_findpackages(self, args):
        packages = self.client.packages.search.advanced(self.session, args)
        
        for p in packages:
            details = self.client.packages.getDetails(self.session, p.get('id'))

            print "Package: " + self.build_package_names([p])[0]
            for provider in details.get('label'):
                print "Provider: " + provider
            print

###########

    def help_listsystems(self):
        print "Usage: listsystems [PATTERN] [PATTERN] ..."
    
    def do_listsystems(self, args, doreturn=False, filtered=True):
        systems = self.client.system.listSystems(self.session)
        systems = [s.get('name') for s in systems]

        if filtered:
            systems = self.filter_results(systems, self.args)

        if doreturn:
            return systems
        else:
            print "\n".join(sorted(systems))

###########

    def help_getsystemdetails(self):
        print "Usage: getsystemdetails SYSTEM1 [SYSTEM2] ..."

    def complete_getsystemdetails(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_listsystems('', True, False), text)
 
    def do_getsystemdetails(self, args):
        add_separator = False

        for system in self.args:
            try:
                # check if we were passed a system ID
                system_id = int(system)
            except ValueError:
                system_id = self.get_system_id(system)

            if not system_id:
                logging.error(system + ' is not a valid system')
                continue

            last_checkin = \
                self.client.system.getName(self.session,
                                           system_id).get('last_checkin')

            details = self.client.system.getDetails(self.session, system_id)

            registered = self.client.system.getRegistrationDate(self.session,
                                                                system_id)
            
            entitlements = self.client.system.getEntitlements(self.session,
                                                              system_id)

            base_channel = \
                self.client.system.getSubscribedBaseChannel(self.session,
                                                            system_id)

            child_channels = \
                self.client.system.listSubscribedChildChannels(self.session,
                                                               system_id)

            groups = self.client.system.listGroups(self.session,
                                                   system_id)

            kernel = self.client.system.getRunningKernel(self.session,
                                                         system_id)
            
            config_channels = \
                self.client.system.config.listChannels(self.session,
                                                       system_id)

            ranked_config_channels = []
            for channel in config_channels:
                ranked_config_channels.append(channel.get('label'))
       
            if add_separator:
                print
                print "--------------------"
                print

            add_separator = True

            print "Name:          " + system
            print "System ID:     " + str(system_id)
            print "Locked:        " + str(details.get('lock_status'))
            print "Registered:    " + registered.value
            print "Last Checkin:  " + last_checkin.value
            print "Kernel:        " + kernel

            print
            print "Software Channels:"
            print '  ' + base_channel.get('label')

            for channel in child_channels:
                print "   |-- " + channel.get('label')

            print
            print 'Configuration Channels:'
            for channel in ranked_config_channels:
                print '  ' + channel

            print
            print "Entitlements:"
            for entitlement in sorted(entitlements):
                print '  ' + self.ENTITLEMENTS[entitlement]

            print
            print "System Groups:"
            for group in groups:
                if group.get('subscribed') == 1:
                    print '  ' + group.get('system_group_name')

###########

    def help_listswchannels(self):
        print "Usage: listswchannels [CHANNEL] [CHANNEL] ..."

    def do_listswchannels(self, args, doreturn=False):
        channels = self.client.channel.listAllChannels(self.session)
        channels = [c.get('label') for c in channels]

        if doreturn:
            return channels
        else:
            print "\n".join(self.filter_results(channels, self.args))
      
###########

    def help_listswchannelsystems(self):
        print "Usage: listswchannelsystems CHANNEL"

    def complete_listswchannelsystems(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_listswchannels('', True), text)

    def do_listswchannelsystems(self, args):
        systems = self.client.channel.software.listSubscribedSystems(self.session,
                                                                     self.args[0])
        
        systems = [s.get('name') for s in systems]

        print "\n".join(systems)

###########

    def help_listswchannelpackages(self):
        print "Usage: listswchannelpackages CHANNEL [PACKAGE] [PACKAGE] ..."

    def complete_listswchannelpackages(self, text, line, begidx, endidx):
        # only tab complete the channel name
        if len(line.split(' ')) == 2:
            return self.tab_completer(self.do_listswchannels('', True), text)
        else:
            return []

    def do_listswchannelpackages(self, args, doreturn=False):
        packages = self.client.channel.software.listLatestPackages(self.session,
                                                                   self.args[0])

        packages = self.build_package_names(packages)

        if doreturn:
            return packages
        else:
            print "\n".join(self.filter_results(packages, self.args[1:])) 
            
###########
 
    def help_getswchanneldetails(self):
        print "Usage: getswchanneldetails CHANNEL [CHANNEL] ..."

    def complete_getswchanneldetails(self, text, line, begidx, endidx):
        return self.tab_completer(self.do_listswchannels('', True), text)
 
    def do_getswchanneldetails(self, args):
        add_separator = False

        for channel in self.args:
            details = self.client.channel.software.getDetails(self.session, 
                                                              channel)
      
            systems = \
                self.client.channel.software.listSubscribedSystems(self.session,                                                                   channel)
 
            if add_separator:
                print
                print "--------------------"
                print

            add_separator = True

            print "Label:              " + details.get('label')
            print "Name:               " + details.get('name')
            print "Architecture:       " + details.get('arch_name')
            print "Parent:             " + details.get('parent_channel_label')
            print "Summary:            " + details.get('summary')
            print "Systems Subscribed: " + str(len(systems))

            print
            print "Description:"
            for line in textwrap.wrap(details.get('description')):
                print line
           
            print 
            print "GPG Key:            " + details.get('gpg_key_id')
            print "GPG Fingerprint:    " + details.get('gpg_key_fp')
            print "GPG URL:            " + details.get('gpg_key_url')


###########

# parse the options and then start the command interpreter
if __name__ == "__main__":
    optionsTable = [
        Option('-u', '--username', action='store',
               help='Use this username to connect to RHN/Satellite'),
        Option('-p', '--password', action='store',
               help='Use this password to connect to RHN/Satellite'),
        Option('--server', action='store', default="localhost", 
               help='Connect to this server (http[s]://<hostname>/APP)'),
        Option('--nocache', action='store_true',
                help="Do not create a username/password cache"),
        Option('--nossl', action='store_true',
               help="Use HTTP instead of HTTPS"),
        Option('--nohistory', action='store_true',
                help="Do not store command history in ~/.spacewalk_history"),
        Option('-d', '--debug', action='store_true',
               help="Enable debug logging"),
    ]
    
    parser = OptionParser(option_list=optionsTable)
    (options, args) = parser.parse_args()
 
    if options.debug:
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO


    # setup logging
    logging.basicConfig(level=log_level, 
                        format="%(levelname)s: %(message)s")

    # setup the shell
    shell = SpacewalkShell(options)

    # start the shell
    while True:
        try:
            shell.cmdloop()
        except xmlrpclib.Fault, err:
            logging.error(err.faultString.rsplit(': ', 1)[1])
        except KeyboardInterrupt:
            print

# vim:ts=4:expandtab:
