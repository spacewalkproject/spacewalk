<datasource_modes>

<write-mode name="remove_org_channel_setting">
  <query params="org_id, cid, label">
DELETE
  FROM rhnOrgChannelSettings OCS
 WHERE OCS.org_id = :org_id
   AND OCS.channel_id = :cid
   AND OCS.setting_id = (SELECT id FROM rhnOrgChannelSettingsType WHERE label = :label)
   </query>
</write-mode>

<write-mode name="add_channel_package">
  <query params="pid, cid">
  INSERT INTO rhnChannelPackage (channel_id, package_id)
  VALUES (:cid, :pid)  
  </query>
</write-mode>

<write-mode name="add_channel_packages">
  <query params="cid">
  INSERT INTO rhnChannelPackage (channel_id, package_id)
      select :cid, P.id from rhnPackage P where P.id in (%s) 
  </query>
</write-mode>

<write-mode name="add_org_channel_setting">
  <query params="org_id, cid, label">
INSERT
  INTO rhnOrgChannelSettings
       (org_id, channel_id, setting_id)
VALUES (:org_id, :cid, (SELECT id FROM rhnOrgChannelSettingsType WHERE label = :label))
  </query>
</write-mode>

<write-mode name="grant_channel_permission">
  <query params="user_id, cid, role_label">
INSERT INTO rhnChannelPermission (channel_id, user_id, role_id)
VALUES (:cid, :user_id, (SELECT id FROM rhnChannelPermissionRole WHERE label = :role_label))
  </query>
</write-mode>

<write-mode name="revoke_channel_permission">
  <query params="user_id, cid, role_label">
DELETE
  FROM rhnChannelPermission CP
 WHERE CP.user_id = :user_id
   AND CP.channel_id = :cid
   AND CP.role_id = (SELECT id FROM rhnChannelPermissionRole WHERE label = :role_label)
  </query>
</write-mode>


<write-mode name="remove_errata">
  <query params="cid">
DELETE
  FROM rhnChannelErrata CE
  where CE.channel_id = :cid
  and  CE.errata_id in (%s)
  </query>
</write-mode>


<write-mode name="remove_packages">
  <query params="cid">
DELETE
  FROM rhnChannelPackage CP
  where CP.channel_id = :cid
  and  CP.package_id in (%s)
  </query>
</write-mode>


<write-mode name="remove_errata_packages">
  <query params="cid">
DELETE
  FROM rhnChannelPackage CP
  where CP.channel_id = :cid
  and  CP.package_id in ( select EP.package_id from
							rhnErrataPackage EP
							where EP.errata_id in (%s))
  </query>
</write-mode>


<write-mode name="request_repo_regen">
  <query params="label, client, reason">
INSERT 
  INTO rhnRepoRegenQueue
        (id, channel_label, client, reason, force, bypass_filters, next_action, created, modified)
VALUES (rhn_repo_regen_queue_id_seq.nextval,
        :label, :client, :reason, 'N', 'N', sysdate, sysdate, sysdate)
  </query>
</write-mode>

<mode name="org_pkg_channels">
  <query params="org_id, pid">
SELECT C.label AS label,
       C.name AS name,
       NVL(C2.label, ' ') AS parent_label
  FROM rhnChannel C2,
       rhnChannel C,
       rhnAvailableChannels AC,
       rhnChannelPackage CP
 WHERE AC.org_id = :org_id
   AND CP.package_id = :pid
   AND AC.channel_id = CP.channel_id
   AND CP.channel_id = C.id
   AND C.parent_channel = C2.id (+)
ORDER BY UPPER(C.name)
  </query>
</mode>

<mode name="org_pkg_channel_ids">
  <query params="org_id, pid">
SELECT C.id AS channel_id
  FROM rhnChannel C2,
       rhnChannel C,
       rhnAvailableChannels AC,
       rhnChannelPackage CP
 WHERE AC.org_id = :org_id
   AND C.org_id = :org_id
   AND CP.package_id = :pid
   AND AC.channel_id = CP.channel_id
   AND CP.channel_id = C.id
   AND C.parent_channel = C2.id (+)
ORDER BY UPPER(C.name)
  </query>
</mode>

<mode name="channels_owned_by_org"
    class="com.redhat.rhn.frontend.dto.ChannelOverview">
    <query params="org_id">
  SELECT C.id, C.name, CC.original_id
    FROM rhnChannel C left join 
    rhnChannelCloned CC on C.id = CC.id
   WHERE C.org_id = :org_id
ORDER BY C.org_id, C.name
    </query> 
</mode>

<mode name="relevant_packages_for_channel_unpublished">
    <query params="eid, cid">
SELECT DISTINCT P1.name_id
  FROM rhnChannel C,
       rhnChannelPackage CP,
       rhnPackage P2,
       rhnPackage P1,
       rhnErrataPackageTmp EP
 WHERE EP.errata_id = :eid
   AND EP.package_id = P1.id
   AND P1.name_id = P2.name_id
   AND P1.package_arch_id = P2.package_arch_id
   AND CP.package_id = P2.id
   AND C.id = CP.channel_id
   AND C.id = :cid
    </query>
</mode>

<mode name="relevant_packages_for_channel_published">
    <query params="eid, cid">
SELECT DISTINCT P1.name_id
  FROM rhnChannel C,
       rhnChannelPackage CP,
       rhnPackage P2,
       rhnPackage P1,
       rhnErrataPackage EP
 WHERE EP.errata_id = :eid
   AND EP.package_id = P1.id
   AND P1.name_id = P2.name_id
   AND P1.package_arch_id = P2.package_arch_id
   AND CP.package_id = P2.id
   AND C.id = CP.channel_id
   AND C.id = :cid
    </query>
</mode>

<mode name="system_channels">
  <query params="sid">
SELECT 
       C.label as label,
       C.name as name
  FROM rhnChannel C,
       rhnServerChannel SC
 WHERE SC.server_id = :sid
   AND SC.channel_id = C.id
ORDER BY C.parent_channel NULLS LAST, UPPER(C.name)
  </query>
</mode>


<mode name="channel_download_categories_by_type" class="com.redhat.rhn.frontend.dto.ISOCategory">
  <query params="channel_label, download_type, org_id">
SELECT RD.category AS CATEGORY, MIN(ordering) AS MIN_ORDER
  FROM rhnDownloads RD,
       rhnDownloadType DT,
       rhnAvailableChannels AC,
       rhnChannelDownloads CD,
       rhnChannel C
 WHERE AC.org_id = :org_id
   AND RD.id = CD.downloads_id
   AND CD.channel_id = C.id
   AND C.label = :channel_label
   AND C.id = AC.channel_id
   AND DT.id = RD.download_type
   AND DT.label = :download_type
GROUP BY RD.category
ORDER BY MIN(ordering)
  </query>
</mode>

<mode name="channel_downloads_by_type" class="com.redhat.rhn.frontend.dto.ISOImage">
  <query params="channel_label, download_type, org_id" >
SELECT RD.name AS DOWNLOAD_NAME,
       RF.path AS DOWNLOAD_PATH,
       CS.checksum AS DOWNLOAD_CHECKSUM,
       RF.file_size AS DOWNLOAD_SIZE,
       RF.id AS FILE_ID,
       RF.id AS ID, -- for datasource, needs ID for elaborator
       RD.category AS CATEGORY
  FROM rhnFile RF,
       rhnDownloads RD,
       rhnDownloadType DT,
       rhnAvailableChannels AC,
       rhnChannelDownloads CD,
       rhnChannel C,
       rhnChecksum CS
 WHERE AC.org_id = :org_id
   AND RD.id = CD.downloads_id
   AND CD.channel_id = C.id
   AND C.label = :channel_label
   AND C.id = AC.channel_id
   AND DT.id = RD.download_type
   AND DT.label = :download_type
   AND RF.id = RD.file_id
   AND RF.checksum_id = CS.id
ORDER BY RD.ordering
  </query>
  <elaborator multiple="t">
SELECT FL.file_id id, FL.location LOCATIONS
  FROM rhnFileLocation FL
 WHERE FL.file_id in (%s)
  </elaborator>
</mode>


<mode name="satellite_channel_download_categories_by_type" class="com.redhat.rhn.frontend.dto.ISOCategory">
  <query params="channel_label, download_type, org_id">
SELECT RD.category AS CATEGORY, MIN(ordering) AS MIN_ORDER
  FROM rhnDownloads RD,
       rhnDownloadType DT,
       rhnSatelliteChannelFamily SCF,
       rhnServer S,
       rhnChannelDownloads CD,
       rhnChannel C
 WHERE S.org_id = :org_id
   AND S.id = SCF.server_id
   AND RD.id = CD.downloads_id
   AND CD.channel_id = C.id
   AND C.label = :channel_label
   AND RD.channel_family_id = SCF.channel_family_id
   AND DT.id = RD.download_type
   AND DT.label = :download_type
GROUP BY RD.category
ORDER BY MIN(ordering)
  </query>
</mode>


<mode name="satellite_channel_downloads_by_type" class="com.redhat.rhn.frontend.dto.ISOImage">
  <query params="org_id, channel_label, download_type">
SELECT DISTINCT RF.id AS ID,
       RD.name AS DOWNLOAD_NAME,
       RF.path AS DOWNLOAD_PATH,
       CS.checksum AS DOWNLOAD_CHECKSUM,
       RF.file_size AS DOWNLOAD_SIZE,
       RF.id AS FILE_ID,
       RD.category AS CATEGORY,
       RD.ordering AS ORDERING
  FROM rhnFile RF,
       rhnDownloads RD,
       rhnDownloadType DT,
       rhnChannelDownloads CD,
       rhnAvailableChannels AC,
       rhnChannel C,
       rhnChecksum CS
 WHERE AC.org_id = :org_id
   AND C.id = AC.channel_id
   AND C.label = :channel_label
   AND CD.channel_id = C.id
   AND RD.id = CD.downloads_id
   AND DT.id = RD.download_type
   AND DT.label = :download_type
   AND RF.id = RD.file_id
   AND RF.checksum_id =  CS.id
ORDER BY RD.ordering
  </query>
  <elaborator multiple="t">
SELECT FL.file_id id, L.label LOCATIONS
  FROM rhnFileLocation FL,
       rhnLocation L
 WHERE l.id = FL.location_id
   AND FL.file_id in (%s)
  </elaborator>
</mode>

<mode name="user_subscribe_perms" class="com.redhat.rhn.frontend.dto.ChannelPerms">
  <query params="user_id, org_id">
SELECT AC.channel_id AS ID,
       AC.channel_name AS NAME, 
       rhn_channel.user_role_check(AC.channel_id, :user_id, 'subscribe') AS HAS_PERM,
       DECODE(
rhn_channel.org_channel_setting(AC.channel_id, :org_id,'not_globally_subscribable'),
0,
1,
NULL
       ) AS GLOBALLY_SUBSCRIBABLE
  FROM rhnAvailableChannels AC
 WHERE AC.org_id = :org_id
ORDER BY UPPER(AC.channel_name)
  </query>
</mode>

<mode name="user_manage_perms" class="com.redhat.rhn.frontend.dto.ChannelPerms">
  <query params="user_id, org_id">
SELECT C.id AS ID,
       C.name AS NAME, 
       rhn_channel.user_role_check(C.id, :user_id, 'manage') AS HAS_PERM
  FROM rhnChannel C
 WHERE C.org_id = :org_id
ORDER BY UPPER(C.name)
  </query>
</mode>

<callable-mode name="verify_channel_role">
  <query params="result, cid, user_id, role, reason">
      {:result = call rhn_channel.user_role_check_debug(:cid, :user_id, :role, :reason)}
  </query>
</callable-mode>


<callable-mode name="update_family_counts">
  <query params="fid, org_id">
      {:result = call rhn_channel.update_family_counts(:fid, :org_id)}
  </query>
</callable-mode>

<mode name="channel_entitlements" class="com.redhat.rhn.frontend.dto.ChannelOverview">
  <query params="org_id">
SELECT CFO.id, CFO.name, CFO.label, CFO.current_members, CFO.max_members, CFO.has_subscription, CFO.url
  FROM rhnChannelFamilyOverview CFO
 WHERE CFO.org_id = :org_id
 ORDER BY CFO.name ASC
  </query>
</mode>

<mode name="channel_entitlements_for_all_orgs" class="com.redhat.rhn.frontend.dto.ChannelOverview">
  <query params="">
SELECT CFO.id, CFO.org_id, CFO.name, CFO.label, CFO.current_members, CFO.max_members, CFO.has_subscription, CFO.url
  FROM rhnChannelFamilyOverview CFO
 ORDER BY CFO.name DESC
  </query>
</mode>

<mode name="channel_entitlements_for_all_m_orgs" class="com.redhat.rhn.frontend.dto.MultiOrgEntitlementsDto">
  <query params="">
SELECT MAX(cfo.id) as id,
		cfo.label,
       cfo.name,
       SUM(cfo.max_members) as total,
       SUM(cfo.current_members) as used,
       (SELECT (cfo2.max_members) - (cfo2.current_members)
       FROM rhnChannelFamilyOverview cfo2
       WHERE 1=1
       AND cfo2.name = cfo.name
       AND cfo2.org_id = 1) as available
FROM rhnChannelFamilyOverview cfo
WHERE cfo.max_members is not null
GROUP BY cfo.label, cfo.name
HAVING SUM(cfo.max_members) is not null
ORDER by cfo.name DESC
  </query>
</mode>

<mode name="channel_entitlement" class="com.redhat.rhn.frontend.dto.ChannelOverview">
  <query params="org_id, entitlement_id">
SELECT CFO.id, CFO.name, CFO.label, CFO.current_members, CFO.max_members, CFO.has_subscription, CFO.url
  FROM rhnChannelFamilyOverview CFO
 WHERE CFO.org_id = :org_id
 AND CFO.id = :entitlement_id
 ORDER BY CFO.name DESC
  </query>
</mode>

<mode name="channel_entitlement_for_all_orgs" class="com.redhat.rhn.frontend.dto.ChannelOverview">
  <query params="entitlement_id">
SELECT CFO.id, CFO.org_id, CFO.name, CFO.label, CFO.current_members, CFO.max_members, CFO.has_subscription, CFO.url
  FROM rhnChannelFamilyOverview CFO
 WHERE CFO.id = :entitlement_id
 AND CFO.org_id in (SELECT ID FROM WEB_CUSTOMER)
 ORDER BY CFO.name DESC
  </query>
</mode>

<mode name="all_channel_tree" class="com.redhat.rhn.frontend.dto.ChannelTreeNode">
	<query params="user_id">
	select Distinct C.id, 
		   C.name, 
		   C.label as channel_label,
		   C.parent_channel as parent_id,
			(SELECT COUNT(P.package_id)
			  FROM rhnChannelPackage P
			  WHERE P.channel_id = C.id
			        ) AS package_count,
         C.org_id,
         (select org.name 
            from web_customer org
            where org.id = C.org_id) as org_name,
         CA.name as arch_name
	from rhnChannel C inner join 
	 rhnUserChannel UC on UC.channel_id = C.id  
        inner join rhnChannelArch CA ON CA.ID  = C.channel_arch_id
	 where UC.user_id = :user_id
    </query>
      <elaborator name="visible_server_count"/>
</mode>

<mode name="shared_channel_tree" class="com.redhat.rhn.frontend.dto.ChannelTreeNode">
   <query params="user_id">
   select Distinct C.id, 
         C.name, 
         C.parent_channel as parent_id,
         C.label as channel_label,
         (SELECT COUNT(P.package_id)
           FROM rhnChannelPackage P
           WHERE P.channel_id = C.id
                 ) AS package_count,
         C.org_id,
         (select org.name 
            from web_customer org
            where org.id = C.org_id) as org_name,
         CA.name as arch_name
    from rhnSharedChannelView C inner join
    rhnUserChannel UC on UC.channel_id = C.id  
    inner join rhnChannelArch CA ON CA.ID  = C.channel_arch_id
    where UC.user_id = :user_id
    </query>
      <elaborator name="visible_server_count"/>
</mode>

<mode name="popular_channel_tree" class="com.redhat.rhn.frontend.dto.ChannelTreeNode">
	<query params="user_id, server_count">
   select Distinct C.id, 
         C.name, 
         C.parent_channel as parent_id,
         C.label as channel_label,
         (SELECT COUNT(P.package_id)
           FROM rhnChannelPackage P
           WHERE P.channel_id = C.id
                 ) AS package_count,
         C.org_id,
         (select org.name 
            from web_customer org
            where org.id = C.org_id) as org_name,
         CA.name as arch_name
	 from rhnChannel C inner join 
	 rhnUserChannel UC on UC.channel_id = C.id  
         inner join rhnChannelArch CA ON CA.ID  = C.channel_arch_id
	 where UC.user_id = :user_id  AND 
	 	   :server_count &lt;= 
	 	   ( select count(SC.server_id)
				from rhnServerChannel SC
				where  SC.channel_id = C.id
				AND EXISTS (SELECT 1 FROM rhnUserServerPerms USP WHERE USP.user_id = :user_id AND USP.server_id = SC.server_id) 
			) 
    </query>
      <elaborator name="visible_server_count"/>
</mode>

<mode name="retired_channel_tree" class="com.redhat.rhn.frontend.dto.ChannelTreeNode">
	<query params="user_id">
   select Distinct C.id, 
         C.name, 
         C.parent_channel as parent_id,
         C.label as channel_label,
         (SELECT COUNT(P.package_id)
           FROM rhnChannelPackage P
           WHERE P.channel_id = C.id
                 ) AS package_count,
         C.org_id,
         (select org.name 
            from web_customer org
            where org.id = C.org_id) as org_name,
         CA.name as arch_name
	from rhnChannel C inner join 
	 rhnUserChannel UC on UC.channel_id = C.id  
        inner join rhnChannelArch CA ON CA.ID  = C.channel_arch_id
	 where UC.user_id = :user_id  and
	 C.end_of_life &lt; sysdate
    </query>
      <elaborator name="visible_server_count"/>
</mode>



<mode name="redhat_channel_tree" class="com.redhat.rhn.frontend.dto.ChannelTreeNode">
	<query params="user_id">
	select Distinct C.id, 
		   C.name, 
		   C.parent_channel as parent_id,
		   C.label as channel_label,
			(SELECT COUNT(P.package_id)
			  FROM rhnChannelPackage P
			  WHERE P.channel_id = C.id
			        ) AS package_count,
                   CA.name as arch_name
	from rhnChannel C inner join 
	 rhnUserChannel UC on UC.channel_id = C.id left join
	 rhnChannel C2 on C.parent_channel = C2.id  
         inner join rhnChannelArch CA ON CA.ID  = C.channel_arch_id
	 where UC.user_id = :user_id  AND
	 		(C.org_id is null  or ( C2.id is not null AND C2.org_id is null ))
    </query>
      <elaborator name="visible_server_count"/>
</mode>

<mode name="my_channel_tree" class="com.redhat.rhn.frontend.dto.ChannelTreeNode">
	<query params="user_id, org_id">
	select Distinct C.id, 
		   C.name, 
		   C.parent_channel as parent_id,
		   C.label as channel_label,
			(SELECT COUNT(P.package_id)
			  FROM rhnChannelPackage P
			  WHERE P.channel_id = C.id
			        ) AS package_count,
                   CA.name as arch_name
	from rhnChannel C inner join 
	 rhnUserChannel UC on UC.channel_id = C.id left join
	 rhnChannel C2 on C2.parent_channel = C.id  
         inner join rhnChannelArch CA ON CA.ID  = C.channel_arch_id
	 where UC.user_id = :user_id  AND
	 		(C.org_id = :org_id  or ( C2.id is not null AND C2.org_id = :org_id ))
    </query>
      <elaborator name="visible_server_count"/>
</mode>

<mode name="trust_channel_consume" class="com.redhat.rhn.frontend.dto.ChannelTreeNode">
	<query params="org_id, org_id2, user_id">
	SELECT DISTINCT V.id, 
	       V.name,
	        0 as accessible,
               V.parent_channel as parent_id,
               (SELECT COUNT(P.package_id)
                FROM rhnChannelPackage P
                WHERE P.channel_id = V.id
               ) AS package_count
	FROM   rhnSharedChannelView V inner join
         rhnUserChannel UC on UC.channel_id = V.id  
        where 1=1
        and v.org_trust_id = :org_id
        AND v.org_id = :org_id2
        AND UC.user_id = :user_id
    </query>
      <elaborator name="visible_server_count"/>
</mode>

<mode name="protected_trust_channel" class="com.redhat.rhn.frontend.dto.OrgChannelDto">
     <query params="org_id, cid">
SELECT wc.id, wc.name,
       NVL((SELECT 1
        FROM rhnchanneltrust rct
        WHERE 1=1
        AND wc.id = rct.org_trust_id
        AND rct.channel_id = :cid),0) AS selected,
       (SELECT count(SC.server_id) 
        FROM rhnServerChannel SC, rhnServer S
        WHERE 1=1
        AND S.org_id = wc.id
        AND S.id = SC.server_id
        AND SC.channel_id = :cid) AS systems
FROM   web_customer wc, rhntrustedorgs rto
WHERE  1=1
AND    rto.org_id = :org_id
AND    wc.id  = rto.org_trust_id
     </query>
</mode>

<mode name="channel_family_tree" class="com.redhat.rhn.frontend.dto.ChannelTreeNode">
  <query params="user_id, family_id">
SELECT DISTINCT C.name NAME,
       C.id ID,
       C.parent_channel as parent_id,
       (
         SELECT COUNT(P.package_id)
           FROM rhnChannelPackage P
           WHERE P.channel_id = C.id
       ) AS PACKAGE_COUNT,
       CFM2.CHANNEL_FAMILY_ID,
       :family_id AS CHANNEL_FAMILY_SEARCHED_FOR
  FROM rhnUserChannel UC,
       rhnChannelFamilyMembers CFM,
       rhnChannel C left join
       rhnChannel C2 on C.id = C2.parent_channel inner join
       rhnChannelFamilyMembers CFM2 on  C.id = CFM2.channel_id 
 WHERE UC.user_id = :user_id
   AND ( CFM.channel_family_id = :family_id )
   AND (
           (C.id = CFM.channel_id  AND  C.id = UC.channel_id)
        OR (C.parent_channel = CFM.channel_id AND C.id = UC.channel_id  )    
        OR (C.id = UC.channel_id  AND C2.id = CFM.channel_id)
        )
  </query>
  <elaborator name="visible_server_count"/>
</mode>



<mode name="channels_with_downloads_tree_full" class="com.redhat.rhn.frontend.dto.ChannelTreeNode">
  <query params="user_id">
SELECT  UACh.channel_name NAME,
        UACh.channel_id ID,
        UACh.channel_depth DEPTH,
        UACh.channel_arch_id,
        UACh.current_members,
        UACh.available_members,
        UACh.parent_or_self_label,
        UACh.parent_or_self_id,
        UACh.channel_label
  FROM  rhnUserAvailableChannels UACh
 WHERE  UACh.user_id = :user_id
   AND  EXISTS (
SELECT 1
  FROM rhnDownloadType DT,
       rhnDownloads D,
       rhnChannelDownloads CD
 WHERE CD.channel_id = UACh.channel_id
   AND CD.downloads_id = D.id
   AND D.download_type = DT.id
   AND DT.label = 'iso'
)
ORDER BY  rhn_channel.channel_priority(UACh.parent_or_self_id),  UACh.parent_or_self_id, UACh.channel_depth, UPPER(UACh.channel_name)
  </query>
</mode>

<mode name="channels_with_downloads_tree_supported" class="com.redhat.rhn.frontend.dto.ChannelTreeNode">
  <query params="user_id">
SELECT  UACh.channel_name NAME,
        UACh.channel_id ID,
        UACh.channel_depth DEPTH,
        UACh.channel_arch_id,
        UACh.current_members,
        UACh.available_members,
        UACh.parent_or_self_label,
        UACh.parent_or_self_id,
        UACh.channel_label
  FROM  rhnUserAvailableChannels UACh
 WHERE  UACh.user_id = :user_id
   AND  EXISTS (
SELECT 1
  FROM rhnDownloadType DT,
       rhnDownloads D,
       rhnChannelDownloads CD
 WHERE CD.channel_id = UACh.channel_id
   AND CD.downloads_id = D.id
   AND D.download_type = DT.id
   AND DT.label = 'iso'
   AND (UACh.end_of_life is NULL OR UACh.end_of_life > sysdate)
)
ORDER BY  rhn_channel.channel_priority(UACh.parent_or_self_id),  UACh.parent_or_self_id, UACh.channel_depth, UPPER(UACh.channel_name)
  </query>
</mode>

<mode name="channels_with_downloads_tree_retired" class="com.redhat.rhn.frontend.dto.ChannelTreeNode">
  <query params="user_id">
SELECT  UACh.channel_name NAME,
        UACh.channel_id ID,
        UACh.channel_depth DEPTH,
        UACh.channel_arch_id,
        UACh.current_members,
        UACh.available_members,
        UACh.parent_or_self_label,
        UACh.parent_or_self_id,
        UACh.channel_label
  FROM  rhnUserAvailableChannels UACh
 WHERE  UACh.user_id = :user_id
   AND  EXISTS (
SELECT 1
  FROM rhnDownloadType DT,
       rhnDownloads D,
       rhnChannelDownloads CD
 WHERE CD.channel_id = UACh.channel_id
   AND CD.downloads_id = D.id
   AND D.download_type = DT.id
   AND DT.label = 'iso'
   AND NOT (UACh.end_of_life is NULL OR UACh.end_of_life > sysdate)
)
ORDER BY  rhn_channel.channel_priority(UACh.parent_or_self_id),  UACh.parent_or_self_id, UACh.channel_depth, UPPER(UACh.channel_name)
  </query>
</mode>

<mode name="channel_tree_ssm_install">
  <query params="org_id, user_id, set_label">
SELECT  ACh.channel_name NAME, ACh.channel_id ID, ACh.channel_depth DEPTH, ACh.channel_arch_id, ACh.current_members, ACh.available_members, (SELECT COUNT(DISTINCT CPN.name_id) FROM rhnChannelNewestPackage CPN WHERE CPN.channel_id = ACh.channel_id) AS PACKAGE_COUNT, ACh.parent_or_self_label, ACh.channel_label
  FROM  rhnAvailableChannels ACh
 WHERE  ACh.org_id = :org_id
   AND  (    ACh.channel_arch_id = lookup_channel_arch('channel-ia32')
          OR  EXISTS (SELECT 1
                 FROM rhnServerChannelArchCompat SCAC, rhnServer S
                WHERE S.org_id = :org_id
                  AND S.server_arch_id = SCAC.server_arch_id
                  AND SCAC.channel_arch_id = ACh.channel_arch_id))
   AND  EXISTS (
SELECT SC.channel_id
  FROM rhnServerChannel SC, rhnSet ST
 WHERE ST.user_id = :user_id
   AND ST.element = SC.server_id
   AND ST.label = :set_label
   AND SC.channel_id = ACh.channel_id
)
ORDER BY  rhn_channel.channel_priority(ACh.parent_or_self_id), ACh.parent_or_self_id, ACh.channel_depth, UPPER(ACh.channel_name)
  </query>
  <elaborator name="visible_server_count"/>
</mode>

<mode name="all_channels_tree">
  <query params="user_id">
SELECT  UACh.channel_name NAME,
        UACh.channel_id ID,
        UACh.channel_depth AS DEPTH,
        UACh.channel_arch_id,
        UACh.current_members,
        UACh.available_members,
        (
SELECT COUNT(P.package_id)
  FROM rhnChannelPackage P
  WHERE P.channel_id = UACh.channel_id
        ) AS PACKAGE_COUNT,
        UACh.parent_or_self_label,
        UACh.parent_or_self_id,
        UACh.channel_label,
  1 show_all_results,
        TO_CHAR(UACh.end_of_life, 'YYYY-MM-DD HH24:MI:SS') AS end_of_life,
        CA.name AS CHANNEL_ARCH
  FROM  rhnChannelArch CA, rhnUserAvailableChannels UACh
 WHERE  UACh.user_id = :user_id
   AND  UACh.channel_arch_id = CA.id
ORDER BY  rhn_channel.channel_priority(UACh.parent_or_self_id), UACh.parent_or_self_id, UACh.channel_depth, UPPER(UACh.channel_name)
  </query>
  <elaborator name="visible_server_count"/>
</mode>

<mode name="owned_channels_tree">
  <query params="user_id">
SELECT CTV.name, CTV.id, CTV.depth, CTV.channel_arch_id, C.org_id,
       (SELECT COUNT (cp.package_id)
          FROM rhnchannelpackage cp
         WHERE cp.channel_id = CTV.id) AS package_count,
       CTV.parent_or_self_label, CTV.label AS channel_label
  FROM rhnchannel C, rhnChannelTreeView CTV, rhnChannel C2
 WHERE CTV.id = C.ID
   AND  CTV.parent_or_self_id = C2.id
   AND (rhn_channel.user_role_check(C.id, :user_id, 'manage') = 1
        OR EXISTS (
              SELECT 1
                FROM rhnChannel C2
               WHERE C2.parent_channel = C.ID
                 AND rhn_channel.user_role_check(C2.id, :user_id, 'manage') = 1))
ORDER BY UPPER(C2.name), depth, UPPER(C.name) 
  </query>
</mode>


<query name="visible_server_count" params="user_id, org_id">
  SELECT SC.channel_id AS ID, count(SC.server_id) as system_count
    FROM rhnServerChannel SC,
         rhnServer S
   WHERE S.org_id = :org_id
     AND S.id = SC.server_id
     AND SC.channel_id IN(%s)
     AND EXISTS (SELECT 1 FROM rhnUserServerPerms USP WHERE USP.user_id = :user_id AND USP.server_id = S.id)
GROUP BY SC.channel_id
</query>

<mode name="subscribable_base_channels_for_system">
  <query params="org_id, server_id">
SELECT  C.id, C.label, C.name
  FROM  rhnChannel C, rhnServerChannelArchCompat SCAC, rhnServer S
 WHERE  C.parent_channel IS NULL
   AND  C.org_id = :org_id 
   AND  S.id = :server_id
   AND  S.server_arch_id = SCAC.server_arch_id
   AND  SCAC.channel_arch_id = C.channel_arch_id
  </query>
</mode>

<mode name="base_channels_for_org"
     class="com.redhat.rhn.frontend.dto.EssentialChannelDto">
  <query params="org_id">
SELECT  C.id, C.name, C.label, 1 AS IS_CUSTOM
  FROM  rhnChannel C
 WHERE  C.parent_channel IS NULL
    AND  C.org_id = :org_id OR
        (C.id, C.org_id)
        IN
        (SELECT S.id, S.org_id
            FROM rhnSharedChannelView S
          WHERE S.ORG_TRUST_ID = :org_id
            AND S.parent_channel IS NULL) order by UPPER(C.name)
  </query>
</mode>

<mode name="base_eus_channels_by_version_release_server_arch"
     class="com.redhat.rhn.frontend.dto.EssentialChannelDto">
  <query params="product_name_label, version, server_arch, user_id, org_id">
        select unique c.id,
               c.label,
               c.name,
               rcm.release,
               0 AS IS_CUSTOM
        from
            rhnChannelPermissions cp,
            rhnChannel c,
            rhnServerArch sa,
            rhnServerChannelArchCompat scac,
            rhnReleaseChannelMap rcm,
            rhnProductName pn
        where
            rcm.version = :version
            and scac.server_arch_id = sa.id
            and sa.label = :server_arch
            and scac.channel_arch_id = rcm.channel_arch_id
            and rcm.channel_id = c.id
            and cp.channel_id = c.id
            and cp.org_id = :org_id
            and pn.id = c.product_name_id
            and pn.label = :product_name_label
            and rhn_channel.loose_user_role_check(c.id, :user_id,
                                                     'subscribe') = 1
        order by c.name
  </query>
</mode>

<mode name="base_eus_channels_by_version_channel_arch"
     class="com.redhat.rhn.frontend.dto.EssentialChannelDto">
  <query params="product_name_label, version, channel_arch_id, user_id, org_id">
        select unique c.id,
               c.label,
               c.name,
               rcm.release,
               0 AS IS_CUSTOM
        from
            rhnChannelPermissions cp,
            rhnChannel c,
            rhnReleaseChannelMap rcm,
            rhnProductName pn
        where
            rcm.version = :version
            and rcm.channel_arch_id = :channel_arch_id
            and rcm.channel_id = c.id
            and cp.channel_id = c.id
            and cp.org_id = :org_id
            and pn.id = c.product_name_id
            and pn.label = :product_name_label
            and rhn_channel.loose_user_role_check(c.id, :user_id,
                                                     'subscribe') = 1
  </query>
</mode>

<mode name="subscribable_channels">
  <query params="server_id, user_id, base_channel_id">
SELECT  DISTINCT C.id,
                 C.label,
                 C.name,
                 C.summary,
                 CFL.channel_family_id AS HAS_LICENSE,
                 C.gpg_key_url
  FROM  rhnChannelFamilyLicense CFL,
        rhnChannelFamilyMembers CFM,
        rhnChannel C,
  rhnUserChannel UC
 WHERE  UC.user_id = :user_id
   AND  UC.role = 'subscribe'
   AND  UC.channel_id = C.id
   AND  C.parent_channel = :base_channel_id
   AND  C.id = CFM.channel_id
   AND  C.parent_channel IS NOT NULL
   AND  NOT EXISTS (SELECT 1 FROM rhnServerChannel WHERE server_id = :server_id AND channel_id = C.id)
   AND  CFM.channel_family_id = CFL.channel_family_id (+)
  </query>
</mode>

<mode name="affected_by_errata" class="com.redhat.rhn.domain.channel.Channel">
  <query params="eid, org_id">
SELECT  DISTINCT C.id, C.name
  FROM  rhnAvailableChannels AC, rhnChannel C, rhnChannelErrata CE
 WHERE  CE.errata_id = :eid
   AND  CE.channel_id = C.id
   AND  AC.org_id = :org_id
   AND  C.id = AC.channel_id
 ORDER  BY UPPER(C.name)
  </query>
</mode>

<mode name="child_channel_candidate">
  <query params="label, sid">
SELECT  1
  FROM  rhnChannel C, rhnChannelFamilyMembers CFM, rhnChannelFamily CF
 WHERE  CF.label = :label
   AND  CF.id = CFM.channel_family_id
   AND  CFM.channel_id = C.id
   AND  C.parent_channel = (SELECT  C.id
                              FROM  rhnChannel C, rhnServerChannel SC
                             WHERE  SC.server_id = :sid
                               AND  SC.channel_id = C.id
                               AND  C.parent_channel IS NULL)
  </query>
</mode>

<mode name="org_errata_channels">
  <query params="org_id, eid">
SELECT C.id as channel_id,
       C.id as id,
       C.label as label,
       C.name as name,
       NVL(C2.label, ' ') as parent_channel_label
  FROM rhnChannel C2,
       rhnChannel C,
       rhnAvailableChannels AC,
       rhnChannelErrata EC
 WHERE EC.errata_id = :eid
   AND AC.org_id = :org_id
   AND AC.channel_id = EC.channel_id
   AND EC.channel_id = C.id
   AND C.parent_channel = C2.id (+)
ORDER BY UPPER(C.name)
  </query>
</mode>

<callable-mode name="subscribe_server_to_channel">
  <query params="server_id, channel_id, user_id">
      {call rhn_channel.subscribe_server(:server_id, :channel_id, 1, :user_id)}
  </query>
</callable-mode>
   
<write-mode name="flag_server_channels_changed">
   <query params="server_id">
      UPDATE rhnServer SET channels_changed = sysdate WHERE id = :server_id
   </query>
</write-mode>
   
<write-mode name="log_channel_history">
   <query params="server_id, channel_id, channel_label, message">
       INSERT INTO rhnServerHistory (id, server_id, summary, details) (
                SELECT  rhn_event_id_seq.nextval,
                        :server_id,
                        :message,
                        :channel_label
                FROM    rhnChannel c
                WHERE   c.id = :channel_id
            )
   </query>
</write-mode>

<callable-mode name="unsubscribe_server_from_channel">
  <query params="server_id, channel_id">
      {call rhn_channel.unsubscribe_server(:server_id, :channel_id)}
  </query>
</callable-mode>

<callable-mode name="delete_channel">
  <query params="cid">
      {call delete_channel(:cid)}
  </query>
</callable-mode>

<mode name="is_package_in_channel" class="com.redhat.rhn.frontend.dto.BooleanWrapper">
    <query params="cid, evr_id, name_id">
SELECT 1 as bool
  FROM rhnChannelPackage CP, rhnPackage P
 WHERE CP.channel_id = :cid
   AND CP.package_id = P.id
   AND P.evr_id = :evr_id
   AND P.name_id = :name_id
    </query>
</mode>

<mode name="families_for_org_without_permissions" class="com.redhat.rhn.frontend.dto.ChannelOverview">
  <query params="org_id">
  SELECT  CF.id
    FROM  rhnChannelFamily CF
   WHERE  CF.org_id = :org_id
 AND NOT  EXISTS (
           SELECT  1
             FROM  rhnChannelFamilyPermissions CFP
            WHERE  CFP.org_id = CF.org_id
              AND  CFP.channel_family_id = CF.id)
ORDER BY  CF.id
  </query>
</mode>

<write-mode name="insert_family_perms">
  <query params="org_id, id">
INSERT INTO  rhnPrivateChannelFamily
             (channel_family_id, org_id, max_members, current_members)
     VALUES  (:id, :org_id, NULL, 0)
  </query>
</write-mode>

<!-- really should probably be mapped -->
<!-- And negative logic SUCKS! -->
<mode name="is_not_globally_subscribable">
    <query params="org_id, cid, label">
        SELECT 1 as setting
  FROM rhnOrgChannelSettings OCS, rhnOrgChannelSettingsType OCST
 WHERE OCS.org_id = :org_id
   AND OCS.channel_id = :cid
   AND OCST.label = :label
   AND OCST.id = OCS.setting_id
    </query>
</mode>

<callable-mode name="refresh_newest_package">
  <query params="cid, label">
      {call rhn_channel.refresh_newest_package(:cid, :label)}
  </query>
</callable-mode>

<mode name="latest_package_equal">
    <query params="cid, name">
SELECT CP.package_id, CP.name_id, CP.evr_id, CP.package_arch_id
  FROM rhnPackageName PN, rhnChannelNewestPackage CP
 WHERE CP.channel_id = :cid
   AND CP.name_id = PN.id
   AND PN.name = :name
    </query>
</mode>

<mode name="latest_package_equal_in_tree">
    <query params="cid, name">
SELECT CP.package_id, CP.name_id, CP.evr_id, CP.package_arch_id
  FROM rhnPackageName PN inner join
               rhnChannelNewestPackage CP on CP.name_id = PN.id inner join
               rhnChannel C on C.id = Cp.channel_id  inner join
               rhnPackage P on P.id = CP.package_id inner join
               rhnPackageEvr EVR on P.evr_id = EVR.id
 WHERE ( C.id = :cid or C.parent_channel = :cid)
   AND PN.name = :name
   AND C.label not like '%beta%'
   order by EVR.evr DESC
    </query>
</mode>

<mode name="latest_package_like">
    <query params="cid, name">
SELECT CP.package_id, CP.name_id, CP.evr_id
  FROM rhnPackageName PN, rhnChannelNewestPackage CP
 WHERE CP.channel_id = :cid
   AND CP.name_id = PN.id
   AND PN.name like :name
    </query>
</mode>

<mode name="channel_with_package">
    <query params="parent, package, org_id">
SELECT  DISTINCT C.id
 FROM  rhnChannel C, rhnChannelPackage CP, rhnPackage P, rhnPackageName PN
 WHERE  C.parent_channel = :parent
   AND  C.id = CP.channel_id
   AND  CP.package_id = P.id
   AND  P.name_id = PN.id
   AND  PN.name = :package
   AND  EXISTS (
        SELECT 1 FROM rhnAvailableChannels AC
        WHERE AC.channel_id = C.id AND AC.org_id = :org_id)
    </query>
</mode>

<mode name="child_channels_with_package">
    <query params="package, org_id">
SELECT  DISTINCT CP.channel_id as id
  FROM  rhnChannelPackage CP
  inner join  rhnPackage P on CP.package_id = P.id 
  inner join  rhnPackageName PN on P.name_id = PN.id
  inner join  rhnChannel C on C.id = CP.channel_id
  inner join rhnAvailableChannels AC on AC.channel_id = C.id
 WHERE  
  PN.name = :package and
  C.parent_channel is not null and
  AC.org_id = :org_id

    </query>
</mode>
    
<callable-mode name="guess_server_base">
  <query params="server_id">
      {:result = call rhn_channel.guess_server_base(:server_id)}
  </query>
</callable-mode>
    
<mode name="children_in_set" class="com.redhat.rhn.frontend.dto.ChildChannelDto">
  <query params="user_id">
select distinct id, name, label, 1 subscribable, parent_id  from (
select 	c.id,
		c.name,
		c.label,
		c.parent_channel AS parent_id
from
		rhnChannelFamilyMembers cfm,
		rhnChannelFamily cf,
		rhnServerChannelArchCompat scac,
		rhnServer s,
		rhnChannel c,
		rhnServerChannel sc,
		rhnUserServerPerms usp,
		rhnSet st
where	1=1
	and st.user_id = :user_id
	and st.label = 'system_list'
	and st.element = s.id
	and usp.user_id = :user_id
	and st.element = usp.server_id
	and st.element = sc.server_id
	and sc.channel_id = c.parent_channel
	and s.server_arch_id = scac.server_arch_id
	and scac.channel_arch_id = c.channel_arch_id
	and c.id = cfm.channel_id
	and cfm.channel_family_id = cf.id
	and cf.label not in ('rhn-satellite','rhn-proxy')
	and rhn_channel.user_role_check(c.id, :user_id, 'subscribe')=1
union all
select	c.id,
		c.name,
		c.label,
		c.parent_channel AS parent_id
from
		rhnUserServerPerms usp,
		rhnChannelFamily cf,
		rhnChannelFamilyMembers cfm,
		rhnChannel c,
		rhnServerChannel sc,
		rhnSet st
where	st.user_id = :user_id
	and st.label = 'system_list'
	and st.element = sc.server_id
	and sc.channel_id = c.id
	and c.parent_channel is not null
	and c.id = cfm.channel_id
	and cfm.channel_family_id = cf.id
	and cf.label not in ('rhn-satellite','rhn-proxy')
	and rhn_channel.user_role_check(cfm.channel_id,:user_id,'subscribe')=1
	and usp.user_id = :user_id
	and st.element = usp.server_id
)
  </query>
</mode>
  
<mode name="base_channels_in_set" class="com.redhat.rhn.frontend.dto.SystemsPerChannelDto">
  <query params="user_id">
  SELECT  C.id, C.name, COUNT(C.id) system_count
  FROM  rhnChannel C,
        rhnServerChannel SC,
        rhnSet ST
 WHERE  ST.user_id = :user_id
   AND  ST.label = 'system_list'
   AND  ST.element = SC.server_id
   AND  SC.channel_id = C.id
   AND  C.parent_channel IS NULL
GROUP BY C.id, C.name
  </query>
</mode>

<mode name="channel_errata_packages" class="com.redhat.rhn.frontend.dto.PackageDto">
  <query params="eid, cid">
  SELECT  P.id, CS.checksum, CS.checksum_type checksum_type,
	   PN.name || '-' || PE.version
	       || '-' || PE.release || (CASE WHEN PE.epoch IS NULL THEN '' ELSE ':' || PE.epoch END)
	       || '-' || PA.label name
	from  rhnPackage P inner join
		  rhnChannelPackage CP on P.id = CP.package_id  inner join
		  rhnErrataPackage EP on EP.package_id = CP.package_id inner join
		  rhnPackageName PN on P.name_id = PN.id inner join
		  rhnPackageEvr PE on  P.evr_id = PE.id inner join
		  rhnPackageArch PA on P.package_arch_id = PA.id inner join
      rhnChecksumView CS on P.checksum_id = CS.id
	where CP.channel_id = :cid
	  and EP.errata_id = :eid
	ORDER by name
  </query>
</mode>


<mode name="ssm_systems_for_child_subscription">
  <query params="set_label, uid">
        select  S.id, C.id as channel_id, S.name, C.name as channel_name
           from rhnServer S inner join
                rhnServerChannel SC on SC.server_id = S.id,
               rhnChannel C,
               rhnServerChannelArchCompat SCAC,
               RhnSet rset
           where
                rset.label = :set_label and
                rset.user_id = :uid and
                rset.element = S.id and
                C.parent_channel = SC.channel_id and
                SCAC.server_arch_id = S.server_arch_id and
                SCAC.channel_arch_id = C.channel_arch_id and
                C.id in (%s) and
                S.id not in (select SC2.server_id
                                from rhnServerChannel SC2
                                where SC2.channel_id = C.id)
  </query>
</mode>

<mode name="ssm_systems_for_child_unsubscription">
  <query params="set_label, uid">
	select  S.id, C.id as channel_id, S.name, C.name as channel_name
	   from rhnServer S inner join
	       rhnServerChannel SC on SC.server_id = S.id  inner join
	       rhnChannel C on C.id = SC.channel_id inner join 
	       rhnSet rset on rset.element = S.id
	   where SC.channel_id in (%s)
	       and  rset.user_id = :uid
	       and  rset.label = :set_label
  </query>
</mode>


<mode name="cloned_original_id">
    <query params="cid">
    SELECT original_id AS id
    FROM rhnChannelCloned
    WHERE id = :cid
    </query>
</mode>


<mode name="compute_channel_family_curent_members">
    <query params="org_id,  cfid">    
  select  count(distinct server_id) as count
          from  rhnChannelFamilyServerPhysical cfsp
         where  cfsp.channel_family_id = :cfid
           and  cfsp.customer_id = :org_id
    </query>
</mode>
<mode name="can_consume_virt_channel">
    <query params="sid,  cfid">    
            select 1
            from
                rhnChannelFamilyVirtSubLevel cfvsl,
                rhnSGTypeVirtSubLevel sgtvsl,
                rhnVirtualInstance vi
            where
                vi.virtual_system_id = :sid 
                and sgtvsl.virt_sub_level_id = cfvsl.virt_sub_level_id
                and cfvsl.channel_family_id = :cfid
                and exists (
                    select 1
                    from rhnServerEntitlementView sev
                    where vi.host_system_id = sev.server_id
                    and sev.server_group_type_id = sgtvsl.server_group_type_id )
    </query>
</mode>
    
</datasource_modes>

