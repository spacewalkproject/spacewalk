<datasource_modes>

<!-- threshold must be in minutes -->
<mode name="errataqueue_find_candidates">
  <query>
SELECT eq.errata_id, E.org_id, EQ.channel_id
  FROM rhnErrataQueue EQ,
       rhnErrata E
   WHERE E.id = EQ.errata_id
ORDER BY next_action DESC
  </query>
</mode>

<mode name="daily_summary_queue_batch"
    class="com.redhat.rhn.frontend.dto.OrgIdWrapper">
  <query params="">
SELECT org_id
  FROM rhnDailySummaryQueue
  </query>
</mode>

<write-mode name="dequeue_daily_summary">
  <query params="org_id">
DELETE FROM rhnDailySummaryQueue WHERE org_id = :org_id
  </query>
</write-mode>

<mode name="users_in_org_wanting_reports"
    class="com.redhat.rhn.frontend.dto.ReportingUser">
  <query params="org_id">
SELECT WC.id, WUPI.email as address, WC.login
  FROM WEB_USER_PERSONAL_INFO WUPI,
       rhnUserInfo UI,
       rhnWebContactEnabled WC
 WHERE WC.org_id = :org_id
   AND WC.id = UI.user_id
   AND UI.email_notify = 1
   AND WC.id = WUPI.web_user_id
  </query>
</mode>

<mode name="users_awol_servers"
      class="com.redhat.rhn.frontend.dto.AwolServer">
  <query params="user_id, checkin_threshold">
SELECT DISTINCT S.id, S.name, SI.checkin
  FROM rhnServer S,
       rhnServerInfo SI,
       rhnUserServerPerms USP
 WHERE USP.user_id = :user_id
   AND USP.server_id = SI.server_id
   AND (sysdate - SI.checkin) BETWEEN 1 AND (1 + :checkin_threshold)
   AND SI.server_id = S.id
   AND NOT EXISTS (
  SELECT *
    FROM rhnUserServerPrefs
   WHERE user_id = :user_id
     AND server_id = S.id
     AND name = 'include_in_daily_summary'
     AND value = 0
)
   AND EXISTS (SELECT 1 FROM rhnServerFeaturesView SFV WHERE SFV.server_id = S.id AND SFV.label = 'ftr_daily_summary')
ORDER BY CHECKIN DESC
  </query>
</mode>

<mode name="get_action_info" class="com.redhat.rhn.frontend.dto.ActionMessage">
  <query params="user_id">
SELECT AT.name as type,
        AStat.name as status,
        COUNT(SA.server_id) as count,
        E.advisory_name AS ADVISORY,
        E.synopsis AS SYNOPSIS
   FROM rhnErrata E,
        rhnActionErrataUpdate AEU,
        rhnActionStatus AStat,
        rhnActionType AT,
        rhnAction A,
        rhnServerAction SA,
        rhnUserServerPerms USP
  WHERE USP.user_id = :user_id
    AND NOT EXISTS (
  SELECT *
    FROM rhnUserServerPrefs
   WHERE user_id = :user_id
     AND server_id = USP.server_id
     AND name = 'include_in_daily_summary'
     AND value = 0
)
    AND EXISTS ( select 1 from rhnServerFeaturesView sfv
                 where sfv.server_id = usp.server_id
                   and sfv.label = 'ftr_daily_summary')
    AND USP.server_id = SA.server_id
    AND sysdate - SA.modified &gt; 0
    AND sysdate - SA.modified &lt; 1
    AND SA.status = AStat.id
    AND SA.action_id = A.id
    AND A.action_type = AT.id
    AND A.id = AEU.action_id (+)
    AND AEU.errata_id = E.id (+)
GROUP BY AT.name, AStat.name, E.advisory_name, E.synopsis
  </query>
</mode>

<write-mode name="errataqueue_enqueue_sat_errata">
   <query params="errata_id,minutes, channel_id">
INSERT
  INTO rhnErrataNotificationQueue
       (errata_id, org_id, next_action, channel_id)
SELECT DISTINCT
       :errata_id, wc.id, sysdate + :minutes / 1440, :channel_id
  FROM web_customer wc,
       rhnChannelErrata CE
 WHERE CE.errata_id = :errata_id
   </query>
</write-mode>

<write-mode name="errataqueue_dequeue_errata_notification">
   <query params="errata_id">
      DELETE FROM rhnErrataNotificationQueue WHERE errata_id = :errata_id
   </query>
</write-mode>

<write-mode name="errataqueue_dequeue_errata">
   <query params="errata_id">
      DELETE FROM rhnErrataQueue WHERE errata_id = :errata_id
   </query>
</write-mode>
    
    
<mode name="errataqueue_find_autoupdate_servers">
  <query params="errata_id, channel_id">
SELECT DISTINCT
       S.id AS server_id, S.org_id org_id
  FROM rhnServer S inner join rhnServerChannel SC on S.id = SC.server_id
 WHERE SC.channel_id = :channel_id and 
			S.id in (SELECT SNV.server_id FROM rhnServerNeededView SNV where NVL(SNV.errata_id, 0) = :errata_id)
 AND EXISTS 
   (SELECT 1 FROM rhnServerFeaturesView SFV WHERE 
    SFV.server_id = S.id AND SFV.label = 'ftr_auto_errata_updates')
 AND s.auto_update IS NOT NULL AND UPPER(s.auto_update) = 'Y'                         
ORDER BY S.org_id
  </query>
</mode>

<mode name="repomd_driver_query">
  <query>
SELECT distinct channel_label
  FROM rhnRepoRegenQueue 
   WHERE next_action is not null
  </query>
</mode>

<mode name="repomd_details_query">
  <query params="channel_label">
SELECT id, channel_label, client, reason, force, bypass_filters, next_action 
  FROM rhnRepoRegenQueue queue
   WHERE next_action is null
   and channel_label = :channel_label
  </query>
</mode>


<write-mode name="repomd_mark_in_progress">
   <query params="channel_label">
      UPDATE rhnRepoRegenQueue set next_action=null, modified=sysdate WHERE channel_label = :channel_label
   </query>
</write-mode>

<write-mode name="repomd_clear_in_progress">
   <query params="">
      UPDATE rhnRepoRegenQueue set next_action=sysdate, modified=sysdate WHERE next_action is null
   </query>
</write-mode>

<write-mode name="repomd_dequeue">
   <query params="channel_label">
      DELETE FROM rhnRepoRegenQueue WHERE channel_label = :channel_label and next_action is null
   </query>
</write-mode>

<!-- Find all abandoned or old KickStart sessions -->
<mode name="kickstartcleanup_find_candidates">
   <query params="">
      SELECT KS.id, KSS.label, KS.action_id, KS.new_server_id, KS.old_server_id
      FROM rhnKickstartSession KS, rhnKickstartSessionState KSS
      WHERE KS.state_id = KSS.id
      AND ((KSS.label NOT IN ('created', 'complete', 'failed') AND KS.last_action &lt; sysdate - 1)
          OR
          (KSS.label = 'created' AND KS.last_action &lt; sysdate - 6))
      AND (KS.kickstart_mode != 'default_session' OR KS.kickstart_mode is NULL)
   </query>
</mode>

<mode name="kickstartcleanup_find_parent_action">
    <query params="action_id">
       SELECT ACT.prerequisite
       FROM rhnAction ACT
       WHERE ACT.id = :action_id
    </query>
</mode>

<mode name="kickstartcleanup_find_failed_state_id">
   <query params="">
      SELECT KSS.id
      FROM rhnKickstartSessionState KSS
      WHERE KSS.label = 'failed'
   </query>
</mode>

<callable-mode name="kickstartcleanup_remove_action">
  <query params="server_id, action_id">
     {call rhn_server.remove_action(:server_id, :action_id)}
  </query>
</callable-mode>

<write-mode name="kickstartcleanup_mark_session_failed">
   <query params="session_id, failed_state_id">
      UPDATE rhnKickstartSession
      SET state_id = :failed_state_id, action_id = NULL
      WHERE id = :session_id
   </query>
</write-mode>

<callable-mode name="synchprobestate_synch_proc">
   <query params="">
      {call rhn_synch_probe_state}
   </query>
</callable-mode>

<callable-mode name="taskomatic_session_cleanup">
   <query params="bound, commit_interval, batch_size, sessions_deleted">
      {call pxt_session_cleanup(:bound, :commit_interval, :batch_size, :sessions_deleted)}
   </query>
</callable-mode>

<mode name="pkgcleanup_find_deleted_pkgs">
   <query params="">
     SELECT PFDQ.path FROM rhnPackageFileDeleteQueue PFDQ
   </query>
</mode>

<write-mode name="pkgcleanup_reset_queue">
   <query params="">
     DELETE FROM rhnPackageFileDeleteQueue
   </query>
</write-mode>

<!-- timings: webdev: 6m (2 records), webqa: 1m 58s (3), prod: 3m 32s (697) -->
<mode name="summarypop_awol_server_in_orgs"
      class="com.redhat.rhn.frontend.dto.OrgIdWrapper">
   <query params="checkin_threshold">
select distinct s.org_id as id
  from rhnServer s
inner join rhnServerInfo si on (si.server_id = s.id)
inner join rhnServerGroup sg on (s.org_id = sg.org_id)
inner join rhnServerGroupType sgt on (sg.group_type = sgt.id)
where sgt.label in ('enterprise_entitled', 'provisioning_entitled')
  and sg.max_members > 0
  and si.checkin between (sysdate + 1) and (sysdate + 1 + :checkin_threshold)
   </query>
</mode>

<!-- timings: webdev: 3m 36s (2), webqa: 11s (3), prod: 3m 21s(697) -->
<mode name="summarypop_awol_server_in_orgs2"
      class="com.redhat.rhn.frontend.dto.OrgIdWrapper">
   <query params="checkin_threshold">
select distinct sg.org_id as id
  from rhnServerGroup sg, rhnServerGroupType sgt
 where SGT.label IN ('enterprise_entitled', 'provisioning_entitled')
   AND SGT.id = SG.group_type
   AND SG.max_members > 0
   and sg.org_id in (
       select s.org_id
         from rhnServer s, rhnServerINfo si
        where s.id = si.SERVER_ID
          AND (sysdate - SI.checkin) BETWEEN 1 AND (1 + :checkin_threshold))
   </query>
</mode>

<!-- timings: webdev: , webqa: , prod:  -->
<mode name="summarypop_orgs_recent_actions"
	class="com.redhat.rhn.frontend.dto.OrgIdWrapper">
   <query params="">
SELECT /*+full(sa)*/  DISTINCT S.org_id as id
  FROM rhnServer S,
       rhnServerAction SA,
       rhnServerGroup SG,
       rhnServerGroupType SGT
 WHERE SGT.label IN ('enterprise_entitled', 'provisioning_entitled')
   AND SGT.id = SG.group_type
   AND SG.max_members > 0
   AND SG.org_id = S.org_id
   AND  S.id = SA.server_id
   AND SA.modified between sysdate - 1 and sysdate
   </query>
</mode>

<mode name="verify_summary_queue">
  <query params="org_id">
SELECT COUNT(*) as queued FROM rhnDailySummaryQueue WHERE org_id = :org_id
  </query>
</mode>

<write-mode name="insert_summary_queue">
  <query params="org_id">
INSERT INTO rhnDailySummaryQueue (org_id) VALUES (:org_id)
  </query>
</write-mode>

<callable-mode name="remove_sandbox_file">
  <query params="id">
  {call rhn_config.delete_file(:id)}
 </query>
</callable-mode>


<callable-mode name="remove_sandbox_channel">
  <query params="channel_id">
  {call rhn_config.delete_channel(:id)}
  </query>
</callable-mode>

<mode name="find_sandbox_file_candidates">
  <query params="window">
SELECT CF.id
FROM rhnConfigFile CF
WHERE CF.config_channel_id IN
    (SELECT cc.Id
     FROM rhnConfigChannel CC
     WHERE CC.created &lt; sysdate - :window
     AND CC.confchan_type_id = 
     (SELECT id FROM rhnConfigChannelType WHERE label = 'server_import'))  
  </query>
</mode>

<mode name="find_sandbox_channel_candidates">
  <query params="window">
SELECT CC.id  
FROM rhnConfigChannel CC
WHERE CC.created &lt; sysdate - :window
AND CC.confchan_type_id = 
   (SELECT id FROM rhnConfigChannelType WHERE label = 'server_import')

  </query>
</mode>

<!-- threshold must be in minutes -->
<mode name="erratamailer_find_errata">
   <query params="threshold">
SELECT enq.errata_id, enq.org_id, enq.channel_id
  FROM rhnErrataNotificationQueue ENQ
 WHERE (enq.next_action &lt; sysdate + :threshold/1440)
ORDER BY next_action DESC
   </query>
</mode>

<write-mode name="erratamailer_mark_errata_done">
   <query params="errata_id,org_id, channel_id">
      UPDATE rhnErrataNotificationQueue 
      SET next_action = NULL 
      WHERE errata_id = :errata_id AND org_id = :org_id and channel_id = :channel_id
   </query>
</write-mode>

<write-mode name="erratamailer_fill_work_queue">
   <query params="errata_id,org_id, channel_id">
  INSERT INTO rhnPaidErrataTempCache
    (user_id, server_id, errata_id)
SELECT DISTINCT USP.user_id,
     S.id as server_id,
     :errata_id
FROM
    rhnPackage P
    inner join rhnPackageEVR P_EVR on P_EVR.id = P.evr_id
    inner join rhnPackageEVR SP_EVR on SP_EVR.evr &lt; P_EVR.evr  
    inner join rhnServerPackage SP on SP.name_id = P.name_id 
               and SP.evr_id = SP_EVR.id
               AND SP.evr_id != P.evr_id
    inner join rhnServer S on SP.server_id = S.id
    inner join rhnServerPackageArchCompat SPAC on spac.server_arch_id = s.server_arch_id 
               AND p.package_arch_id = spac.package_arch_id
    inner join rhnServerChannel SC on SC.server_id = S.id 
    inner join rhnUserServerPerms USP on USP.server_id = S.id
    inner join web_user_personal_info WPI on WPI.web_user_id = USP.user_id
    inner join rhnUserInfo UI on UI.user_id = USP.user_id
    inner join rhnChannelPackage CP on CP.package_id = P.id 
               and SC.channel_id = CP.channel_id
    inner join rhnErrataPackage EP on EP.package_id = P.id
                   AND EXISTS 
                   (SELECT 1 from rhnChannelErrata CE where ce.channel_id = SC.channel_id
                    AND CE.errata_id = EP.errata_id) 
    where SP_EVR.evr = (SELECT MAX(PE.evr) FROM rhnServerPackage SP2, rhnPackageEvr PE 
                       WHERE PE.id = SP2.evr_id AND SP2.server_id = SP.server_id AND 
                        SP2.name_id = SP.name_id)    
    and not exists (
      select   usprefs.server_id 
               from  rhnUserServerPrefs usprefs
         where usprefs.user_id = USP.user_id
               and sc.server_id = usprefs.server_id 
               and usprefs.name = 'receive_notifications'
   )
   and ui.email_notify = 1
   and not exists ( select 1
                      from rhnWebContactDisabled wcd
                     where wcd.id = USP.user_id )
   and WPI.email is not null
   AND SC.channel_id = :channel_id
   AND S.org_id = :org_id
   AND EP.errata_id = :errata_id
   </query>
</write-mode>

<mode name="erratamailer_find_users">
   <query params="">
  SELECT distinct WC.id, WC.org_id, WC.login, WUPI.email
    FROM web_user_personal_info WUPI,
         web_contact WC,
         rhnPaidErrataTempCache PETC
   WHERE WC.id = PETC.user_id
     AND WUPI.web_user_id = WC.id
   </query>
</mode>

<mode name="erratamailer_find_servers">
   <query params="user_id">
  SELECT S.id, S.name, S.release, SA.name as arch, C.name base_channel
    FROM rhnChannel C,
         rhnServerChannel SC,
         rhnServer S,
         rhnServerArch SA,
         rhnPaidErrataTempCache PETC
   WHERE S.server_arch_id = SA.id
     AND S.id = PETC.server_id
     AND PETC.user_id = :user_id
     AND S.id = SC.server_id
     AND SC.channel_id = C.id
     AND C.parent_channel IS NULL
   ORDER BY 3,4,2
   </query>
</mode>

<mode name="repomdgenerator_channel_packages"
    class="com.redhat.rhn.frontend.dto.PackageDto">
   <query params="channel_id">
  SELECT /*+ ORDERED */ p.id, pn.name as name, pevr.epoch as epoch,
         pevr.version as version, pevr.release as release,
         p.summary, p.description, pa.label as arch_label,
         p.build_time, p.path, p.package_size, p.payload_size,
         p.copyright, p.vendor, p.build_host, p.header_start, p.header_end,
         srpm.name as source_rpm, pg.name as package_group_name,
         cs.checksum, cs.checksum_type as checksum_type,
         prd.primary as primary_xml, prd.filelist as filelist_xml, prd.other as other_xml
    FROM
         rhnChannelPackage cp,
         rhnPackage p
            LEFT OUTER JOIN rhnPackageGroup pg ON p.package_group = pg.id
            LEFT OUTER JOIN rhnSourceRpm srpm  ON p.source_rpm_id = srpm.id
            LEFT JOIN rhnPackageRepodata prd ON prd.package_id = p.id,
         rhnPackageName pn,
         rhnPackageEvr pevr,
         rhnPackageArch pa,
         rhnChecksumView cs
    WHERE
         cp.package_id = p.id
         AND p.name_id = pn.id
         AND p.evr_id = pevr.id
         AND p.package_arch_id = pa.id
         AND cp.channel_id = :channel_id
         AND p.checksum_id = cs.id
    ORDER by 1
   </query>
</mode>

<mode name="repomdgenerator_capability_files">
   <query params="channel_id">
  SELECT /*+first_rows*/ chpkg.package_id, pkgcap.id, pkgcap.name, pkgcap.version
    FROM rhnPackageFile pkgf, rhnPackageCapability pkgcap, 
         rhnChannelPackage chpkg left join  rhnPackageRepodata prd ON prd.package_id = chpkg.package_id
    WHERE
          chpkg.package_id = pkgf.package_id
      AND pkgf.capability_id = pkgcap.id
      AND chpkg.channel_id = :channel_id
      AND prd.primary is null
  ORDER BY pkgf.package_id
   </query>
</mode>

<mode name="repomdgenerator_capability_provides">
   <query params="channel_id">
  SELECT /*+first_rows*/  chpkg.package_id, pkgcap.id, pkgcap.name, pkgcap.version, pkgp.sense
    FROM rhnPackageProvides pkgp, rhnPackageCapability pkgcap, 
    	rhnChannelPackage chpkg left join  rhnPackageRepodata prd ON prd.package_id = chpkg.package_id
    WHERE
          chpkg.package_id = pkgp.package_id
      AND pkgp.capability_id = pkgcap.id
      AND chpkg.channel_id = :channel_id
      AND prd.primary is null
  ORDER BY pkgp.package_id
   </query>
</mode>

<mode name="repomdgenerator_capability_requires">
   <query params="channel_id">
  SELECT /*+first_rows*/ chpkg.package_id, pkgcap.id, pkgcap.name, pkgcap.version, pkgp.sense
    FROM rhnPackageRequires pkgp, rhnPackageCapability pkgcap, 
    	rhnChannelPackage chpkg left join  rhnPackageRepodata prd ON prd.package_id = chpkg.package_id
    WHERE
          chpkg.package_id = pkgp.package_id
      AND pkgp.capability_id = pkgcap.id
      AND chpkg.channel_id = :channel_id
      AND prd.primary is null
  ORDER BY pkgp.package_id
   </query>
</mode>

<mode name="repomdgenerator_capability_conflicts">
   <query params="channel_id">
  SELECT  /*+first_rows*/ chpkg.package_id, pkgcap.id, pkgcap.name, pkgcap.version, pkgp.sense
    FROM rhnPackageConflicts pkgp, rhnPackageCapability pkgcap, 
    	rhnChannelPackage chpkg left join  rhnPackageRepodata prd ON prd.package_id = chpkg.package_id
    WHERE
          chpkg.package_id = pkgp.package_id
      AND pkgp.capability_id = pkgcap.id
      AND chpkg.channel_id = :channel_id
      AND prd.primary is null
  ORDER BY pkgp.package_id
   </query>
</mode>

<mode name="repomdgenerator_capability_obsoletes">
   <query params="channel_id">
  SELECT  /*+first_rows*/ chpkg.package_id, pkgcap.id, pkgcap.name, pkgcap.version, pkgp.sense
    FROM rhnPackageObsoletes pkgp, rhnPackageCapability pkgcap, 
    	rhnChannelPackage chpkg left join  rhnPackageRepodata prd ON prd.package_id = chpkg.package_id
    WHERE
          chpkg.package_id = pkgp.package_id
      AND pkgp.capability_id = pkgcap.id
      AND chpkg.channel_id = :channel_id
      AND prd.primary is null
  ORDER BY pkgp.package_id
   </query>
</mode>

<mode name="repomdgenerator_package_changelog">
   <query params="channel_id">
  SELECT /*+first_rows*/ chpkg.package_id, pkglog.time, pkglog.name as author, pkglog.text
    FROM rhnPackageChangeLog pkglog, rhnChannelPackage chpkg
    WHERE
          chpkg.package_id = pkglog.package_id
      AND chpkg.channel_id = :channel_id
  ORDER BY pkglog.package_id
   </query>
</mode>

<write-mode name="erratamailer_clean_work_queue">
   <query params="">
      DELETE rhnPaidErrataTempCache
   </query>
</write-mode>

<mode name="find_task_stats">
  <query params="display_name">
    SELECT COUNT(LABEL) as stat_exists
    FROM rhnDaemonState
    WHERE LABEL = :display_name
  </query>
</mode>

<write-mode name="create_task_stats">
  <query params="display_name">
    INSERT INTO rhnDaemonState (LABEL, LAST_POLL)
    VALUES (:display_name, sysdate)
  </query>
</write-mode>

<write-mode name="update_task_stats">
  <query params="display_name">
    UPDATE rhnDaemonState
      SET LAST_POLL = sysdate
      WHERE LABEL = :display_name
  </query>
</write-mode>

<mode name="get_task_stats">
	<query params="label">
		SELECT LAST_POLL
		FROM rhnDaemonState
		WHERE label = :label
	</query>
</mode>

<mode name="get_current_time">
	<query params="">
		SELECT sysdate
		FROM dual
	</query>
</mode>

<mode name="find_channel_in_task_queue">
	<query params="cid">
		SELECT task_data
		FROM rhnTaskQueue
		WHERE task_data = :cid
		AND task_name = 'update_errata_cache_by_channel'
	</query>
</mode>

<write-mode name="update_task_queue">
	<query params="earliest, cid">
		UPDATE rhnTaskQueue
   		SET earliest = :earliest
 		WHERE task_data = :cid
 	</query>
</write-mode>

<write-mode name="insert_into_task_queue">
	<query params="org_id, task_data, cid, earliest">
	INSERT INTO rhnTaskQueue
       (org_id, task_name, task_data, priority, earliest)
		VALUES (:org_id, :task_data, :cid, 0, :earliest)
	</query>
</write-mode>

<write-mode name="delete_task">
  <query params="org_id, name, task_data, priority">
  DELETE rhnTaskQueue where org_id = :org_id and task_name = :name 
  and task_data = :task_data and priority = :priority
  </query>
</write-mode>

</datasource_modes>
